{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to BTS SIO 1\u00e8re ann\u00e9e Learning Site","title":"Welcome to BTS SIO 1\u00e8re ann\u00e9e Learning Site"},{"location":"#welcome-to-bts-sio-1ere-annee-learning-site","text":"","title":"Welcome to BTS SIO 1\u00e8re ann\u00e9e Learning Site"},{"location":"Cybersecurite/authentification/","text":"Les principes de l'authentification Introduction Avec la multiplication des services en ligne (messagerie, sites marchands, h\u00e9bergement de documents, r\u00e9seaux sociaux, etc.), nous devons aujourd\u2019hui g\u00e9rer de nombreux mots de passe. En obtenant le mot de passe d\u2019une personne, l\u2019attaquant prend possession du moyen d\u2019acc\u00e9der \u00e0 des services et informations utiles. Un v\u00e9ritable s\u00e9same pour une personne malveillante ! Comment les choisir ? Comment les retenir ? Quels sont les risques en cas de vol de mot de passe et que faire ? Dans cette unit\u00e9, nous allons tenter de r\u00e9pondre \u00e0 quelques-unes de ces questions et de vous donner quelques bonnes pratiques \u00e0 adopter. Objectif de l'authentification Lorsque vous vous connectez sur un service, il vous est demand\u00e9 de vous authentifier . Pour cela on vous demande g\u00e9n\u00e9ralement de communiquer un nom d'utilisateur (l'identit\u00e9) et un mot de passe. L\u2019authentification est une \u00e9tape de contr\u00f4le indispensable puisqu\u2019elle vise \u00e0 v\u00e9rifier l\u2019identit\u00e9 communiqu\u00e9e par un utilisateur lors de sa connexion sur un service. Le principe d'authentification est une brique essentielle pour permettre la mise en place des m\u00e9canismes de s\u00e9curit\u00e9 des services en ligne. C'est le cas notamment du contr\u00f4le des acc\u00e8s , qui permet de g\u00e9rer les autorisations pour acc\u00e9der \u00e0 vos donn\u00e9es en s'appuyant sur l'identit\u00e9 authentifi\u00e9e. Pour acc\u00e9der \u00e0 vos donn\u00e9es, deux principes diff\u00e9rents sont ainsi mis en \u0153uvre : le principe d'authentification et le principe d'autorisation. Par exemple, lorsque vous avez saisi votre identifiant et votre mot de passe sur votre service de messagerie en ligne ( principe d'authentification ), vous pouvez consulter vos propres messages mais pas ceux re\u00e7us par d'autres utilisateurs (principe d'autorisation). Et inversement, ces autres utilisateurs ne peuvent pas consulter vos messages. OBJECTIFS Le principe d'authentification est \u00e9galement utilis\u00e9 pour assurer l'imputabilit\u00e9 (c\u2019est-\u00e0-dire pour apporter la preuve de qui a fait quoi) et la tra\u00e7abilit\u00e9 des actions (c\u2019est-\u00e0-dire conserver l'historique des actions). Ainsi, lorsque vous t\u00e9l\u00e9-d\u00e9clarez vos imp\u00f4ts en ligne par exemple, l'imputabilit\u00e9 permet de faire le lien entre votre d\u00e9claration et votre identit\u00e9 authentifi\u00e9e. La tra\u00e7abilit\u00e9, quant \u00e0 elle, permet de conna\u00eetre l'heure \u00e0 laquelle vous avez soumis votre d\u00e9claration d'imp\u00f4ts. Facteurs de l'authentification OBJECTIFS L'authentification consiste \u00e0 apporter la preuve de son identit\u00e9 mais il existe plusieurs fa\u00e7ons de la prouver. Celles-ci se r\u00e9partissent en plusieurs cat\u00e9gories : on parle de facteurs d'authentification . Les diff\u00e9rents facteurs sont la connaissance, la possession ou encore les caract\u00e9ristiques biom\u00e9triques . Les facteurs de connaissance sont aujourd\u2019hui la cat\u00e9gorie la plus r\u00e9pandue. Cette cat\u00e9gorie regroupe les preuves correspondant \u00e0 \u00ab ce que je connais \u00bb. Ces preuves peuvent \u00eatre par exemple : Un mot de passe. Un code PIN de carte \u00e0 puce (ex : un code de carte bancaire). La r\u00e9ponse \u00e0 une question secr\u00e8te et connue de vous seul(e). Un sch\u00e9ma de d\u00e9verrouillage (ex : d\u00e9verrouillage des smartphones). Soyez vigilant lorsque vous d\u00e9finissez des mots de passe. Vous devez faire attention \u00e0 d\u00e9finir des mots de passe complexes (dont on parlera dans l\u2019unit\u00e9 3 de ce module), et \u00e0 vous assurer que les r\u00e9ponses \u00e0 vos questions secr\u00e8tes ne sont pas trivialement retrouvables. En effet, si vous choisissez comme question secr\u00e8te \u00ab Quel est le nom de jeune-fille de ma m\u00e8re ? \u00bb la r\u00e9ponse peut \u00eatre tr\u00e8s facile \u00e0 trouver par un attaquant, le risque de d\u00e9couverte de votre mot de passe sera donc plus grand. La deuxi\u00e8me cat\u00e9gorie regroupe les facteurs de possession c\u2019est-\u00e0-dire les preuves qui correspondent \u00e0 \u00ab ce que je poss\u00e8de \u00bb. Dans nos activit\u00e9s professionnelles, il peut s\u2019agir de : Un t\u00e9l\u00e9phone portable (ex : un code \u00e0 usage unique envoy\u00e9 par SMS). Une carte \u00e0 puce (ex : carte bancaire, passeport \u00e9lectronique, carte vitale). Un badge, une cl\u00e9 USB de s\u00e9curit\u00e9. Un g\u00e9n\u00e9rateur de mot de passe \u00e0 usage unique (ex : certaines banques fournissent un bo\u00eetier pour valider des op\u00e9rations bancaires comme les virements), etc. Enfin, la troisi\u00e8me cat\u00e9gorie regroupe les preuves qui correspondent \u00e0 \u00ab ce que je suis \u00bb. Il s\u2019agit d\u2019 \u00e9l\u00e9ments biom\u00e9triques (ou inh\u00e9rents) tels que : Une empreinte digitale. Une empreinte r\u00e9tinienne. La structure de la main. La structure du visage. La voix. etc. L'avantage de cette m\u00e9thode est que l'utilisateur a toujours sur lui ses \u00ab codes d'authentification \u00bb et ne peut pas les perdre ou les oublier. Cependant, \u00e0 l\u2019inverse d\u2019un facteur de connaissance ou de possession, les \u00e9l\u00e9ments biom\u00e9triques sont fixes, ce qui peut poser des probl\u00e8mes vis \u00e0 vis de la vie priv\u00e9e. 1 FACTEUR = AUTHENTIFICATION SIMPLE L'authentification \u00e9lectronique par identifiant et mot de passe met en \u0153uvre un unique facteur d'authentification, \u00e0 savoir le mot de passe qui rentre dans la cat\u00e9gorie des facteurs de connaissance : on parle alors d'authentification simple. PLUSIEURS FACTEURS = AUTHENTIFICATION FORTE Lorsque le m\u00e9canisme d'authentification met en \u0153uvre plusieurs facteurs d'authentification, on parle alors d'authentification forte. L\u2019authentification forte m\u00eale ainsi diff\u00e9rents types de facteurs d\u2019authentification comme la connaissance associ\u00e9e \u00e0 la possession. Ce type d'authentification est souvent utilis\u00e9 pour se prot\u00e9ger des faiblesses pouvant \u00eatre li\u00e9es aux mots de passe. Aujourd\u2019hui, il est en effet assez r\u00e9pandu de pouvoir activer un deuxi\u00e8me facteur d'authentification pour acc\u00e9der \u00e0 sa messagerie \u00e9lectronique et de devoir saisir un code re\u00e7u par SMS apr\u00e8s avoir entr\u00e9 son mot de passe. Limites des facteurs d'authentification LA BIOM\u00c9TRIE De toutes les m\u00e9thodes d\u2019authentification vues ensemble, aujourd\u2019hui, la biom\u00e9trie est sans doute la m\u00e9thode la plus prometteuse, mais aussi la plus d\u00e9licate \u00e0 mettre en \u0153uvre pour plusieurs raisons. LIMITES DE LA BIOM\u00c9TRIE Il existe toutefois plusieurs limites \u00e0 la biom\u00e9trie. Tout d'abord, la biom\u00e9trie co\u00fbte cher et n\u00e9cessite de lourds moyens pour \u00eatre mise en place. Ensuite, elle pose des probl\u00e8mes sur l'aspect juridique du fait de stocker les caract\u00e9ristiques morphologiques des personnes. Notez \u00e9galement que certaines techniques d'authentification biom\u00e9triques sont plus susceptibles d'\u00eatre contourn\u00e9es que d'autres. Par exemple, les techniques courantes de reconnaissance du visage peuvent \u00eatre mises \u00e0 mal par une simple photo. Et c\u2019est sans compter les \u00e9ventuels probl\u00e8mes d\u2019acc\u00e8s qui pourraient survenir avec une voix enrou\u00e9e ou encore des mains br\u00fbl\u00e9es\u2026 L'un des axes de recherche de la biom\u00e9trie porte donc sur la multimodalit\u00e9 , c'est-\u00e0-dire la combinaison de plusieurs m\u00e9thodes d'identification par voie biom\u00e9trique. L\u00e0 encore les co\u00fbts restent aujourd\u2019hui un facteur limitant pour sa mise en place . EXEMPLE EN BELGIQUE Il est important de noter que ce syst\u00e8me connait \u00e9galement quelques d\u00e9rives \u00e0 la crois\u00e9e entre les facteurs de possession et biom\u00e9trique . En Belgique par exemple, certains employ\u00e9s ont accept\u00e9 de se faire implanter des puces sous la peau . Notons toutefois que ce type de solutions a peu de chance de voir le jour en France puisqu\u2019il est, entre autres, contraire \u00e0 l\u2019application du r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es personnelles (RGPD) . En effet, ces bases de donn\u00e9es sont \u00e0 rapprocher de celles utilis\u00e9es par la police et sont donc soumises \u00e0 des lois tr\u00e8s strictes. Les risques li\u00e9s aux mots de passe Pr\u00e9sentation Le mot de passe est aujourd\u2019hui le mode d\u2019authentification le plus r\u00e9pandu . En effet, c\u2019est le mode d\u2019authentification le plus simple \u00e0 mettre en place sur nos services quotidiens. Mais ce mot de passe n\u2019est pas exempt de risques . Divulgation M\u00eame s\u2019il n\u2019\u00e9limine pas l\u2019ensemble des risques, le principe d'authentification permet toutefois de r\u00e9duire les risques d'usurpation d'identit\u00e9. Les risques peuvent varier en fonction du type d'authentification et de la nature des preuves apport\u00e9es. En particulier, un mot de passe est un \u00e9l\u00e9ment secret que vous seul devez conna\u00eetre car il conditionne l'acc\u00e8s \u00e0 vos donn\u00e9es et services en ligne. Le risque principal li\u00e9 \u00e0 son utilisation est donc sa divulgation \u00e0 un tiers qui pourrait en faire un usage malveillant. Les causes de divulgation peuvent \u00eatre multiples, de la n\u00e9gligence \u00e0 la malveillance. N\u00e9gligeance On parle de divulgation par n\u00e9gligence dans les cas suivants : Utilisation d'un mot de passe faible (ex : 0000, 123456, motdepasse) ; Inscription du mot de passe sur un support accessible \u00e0 un tiers (post-it sous le clavier, tableau blanc, etc.) ; Diffusion \u00e0 un tiers (coll\u00e8gue, ami, op\u00e9rateur de service informatique, mot de passe envoy\u00e9 par email, etc.) oralement ou par \u00e9crit (papier, mail, etc.) ; Authentification sur un service via un protocole non s\u00e9curis\u00e9 tels que HTTP, IMAP, POP3, etc. au lieu de HTTPS, IMAPS, POPS ; Utilisation d'un ordinateur/smartphone qui ne soit pas de confiance et potentiellement infect\u00e9 (cybercaf\u00e9, ordinateur en libre acc\u00e8s dans un h\u00f4tel, etc.) ; Mot de passe enregistr\u00e9 sur le navigateur internet sans protection . Malveillance La divulgation de mot de passe peut \u00e9galement faire suite \u00e0 un acte de malveillance. Il peut s\u2019agir : D\u2019une authentification sur un service ill\u00e9gitime (hame\u00e7onnage ou phishing, dont on parlera dans l\u2019unit\u00e9 2 de ce module) D\u2018une attaque par ing\u00e9nierie sociale (utilisation de vos donn\u00e9es personnelles pour vous pi\u00e9ger) D\u2019une attaque par force brute ou de la divulgation d\u2019une base de donn\u00e9es de mots de passe d\u2019un service mal s\u00e9curis\u00e9. Ces diff\u00e9rentes causes de divulgation seront abord\u00e9es en d\u00e9tail dans la suite de ce cours. Gardez en t\u00eate que lorsque votre mot de passe a \u00e9t\u00e9 divulgu\u00e9, il perd son caract\u00e8re confidentiel . Un individu malveillant peut alors usurper votre identit\u00e9 sur un service en ligne et effectuer des actions en votre nom. Les cons\u00e9quences varient en fonction du type de service impact\u00e9 et des objectifs des individus malveillants : Compromission de messages personnels sur votre messagerie \u00e9lectronique ; Destruction de donn\u00e9es ; Publication de messages ou photos pr\u00e9judiciables sur vos r\u00e9seaux sociaux ; Achats sur des sites de vente en ligne (certains sites proposent en effet de conserver votre num\u00e9ro de carte bancaire) ; Virements bancaires sur le site de votre banque, etc. ; Conclusion L'usurpation d'identit\u00e9 peut avoir des cons\u00e9quences importantes pour vous et par extension pour votre entreprise . C\u2019est pourquoi, si vous \u00eates victime d'usurpation d'identit\u00e9, il est n\u00e9cessaire de suivre les conseils suivants : Pour limiter ces risques, il convient d'appliquer un certain nombre de bonnes pratiques que vous d\u00e9couvrirez dans la suite de votre parcours.","title":"Les principes de l'authentification"},{"location":"Cybersecurite/authentification/#les-principes-de-lauthentification","text":"","title":"Les principes de l'authentification"},{"location":"Cybersecurite/authentification/#introduction","text":"Avec la multiplication des services en ligne (messagerie, sites marchands, h\u00e9bergement de documents, r\u00e9seaux sociaux, etc.), nous devons aujourd\u2019hui g\u00e9rer de nombreux mots de passe. En obtenant le mot de passe d\u2019une personne, l\u2019attaquant prend possession du moyen d\u2019acc\u00e9der \u00e0 des services et informations utiles. Un v\u00e9ritable s\u00e9same pour une personne malveillante ! Comment les choisir ? Comment les retenir ? Quels sont les risques en cas de vol de mot de passe et que faire ? Dans cette unit\u00e9, nous allons tenter de r\u00e9pondre \u00e0 quelques-unes de ces questions et de vous donner quelques bonnes pratiques \u00e0 adopter.","title":"Introduction"},{"location":"Cybersecurite/authentification/#objectif-de-lauthentification","text":"Lorsque vous vous connectez sur un service, il vous est demand\u00e9 de vous authentifier . Pour cela on vous demande g\u00e9n\u00e9ralement de communiquer un nom d'utilisateur (l'identit\u00e9) et un mot de passe. L\u2019authentification est une \u00e9tape de contr\u00f4le indispensable puisqu\u2019elle vise \u00e0 v\u00e9rifier l\u2019identit\u00e9 communiqu\u00e9e par un utilisateur lors de sa connexion sur un service. Le principe d'authentification est une brique essentielle pour permettre la mise en place des m\u00e9canismes de s\u00e9curit\u00e9 des services en ligne. C'est le cas notamment du contr\u00f4le des acc\u00e8s , qui permet de g\u00e9rer les autorisations pour acc\u00e9der \u00e0 vos donn\u00e9es en s'appuyant sur l'identit\u00e9 authentifi\u00e9e. Pour acc\u00e9der \u00e0 vos donn\u00e9es, deux principes diff\u00e9rents sont ainsi mis en \u0153uvre : le principe d'authentification et le principe d'autorisation. Par exemple, lorsque vous avez saisi votre identifiant et votre mot de passe sur votre service de messagerie en ligne ( principe d'authentification ), vous pouvez consulter vos propres messages mais pas ceux re\u00e7us par d'autres utilisateurs (principe d'autorisation). Et inversement, ces autres utilisateurs ne peuvent pas consulter vos messages.","title":"Objectif de l'authentification"},{"location":"Cybersecurite/authentification/#objectifs","text":"Le principe d'authentification est \u00e9galement utilis\u00e9 pour assurer l'imputabilit\u00e9 (c\u2019est-\u00e0-dire pour apporter la preuve de qui a fait quoi) et la tra\u00e7abilit\u00e9 des actions (c\u2019est-\u00e0-dire conserver l'historique des actions). Ainsi, lorsque vous t\u00e9l\u00e9-d\u00e9clarez vos imp\u00f4ts en ligne par exemple, l'imputabilit\u00e9 permet de faire le lien entre votre d\u00e9claration et votre identit\u00e9 authentifi\u00e9e. La tra\u00e7abilit\u00e9, quant \u00e0 elle, permet de conna\u00eetre l'heure \u00e0 laquelle vous avez soumis votre d\u00e9claration d'imp\u00f4ts.","title":"OBJECTIFS"},{"location":"Cybersecurite/authentification/#facteurs-de-lauthentification","text":"","title":"Facteurs de l'authentification"},{"location":"Cybersecurite/authentification/#objectifs_1","text":"L'authentification consiste \u00e0 apporter la preuve de son identit\u00e9 mais il existe plusieurs fa\u00e7ons de la prouver. Celles-ci se r\u00e9partissent en plusieurs cat\u00e9gories : on parle de facteurs d'authentification . Les diff\u00e9rents facteurs sont la connaissance, la possession ou encore les caract\u00e9ristiques biom\u00e9triques . Les facteurs de connaissance sont aujourd\u2019hui la cat\u00e9gorie la plus r\u00e9pandue. Cette cat\u00e9gorie regroupe les preuves correspondant \u00e0 \u00ab ce que je connais \u00bb. Ces preuves peuvent \u00eatre par exemple : Un mot de passe. Un code PIN de carte \u00e0 puce (ex : un code de carte bancaire). La r\u00e9ponse \u00e0 une question secr\u00e8te et connue de vous seul(e). Un sch\u00e9ma de d\u00e9verrouillage (ex : d\u00e9verrouillage des smartphones). Soyez vigilant lorsque vous d\u00e9finissez des mots de passe. Vous devez faire attention \u00e0 d\u00e9finir des mots de passe complexes (dont on parlera dans l\u2019unit\u00e9 3 de ce module), et \u00e0 vous assurer que les r\u00e9ponses \u00e0 vos questions secr\u00e8tes ne sont pas trivialement retrouvables. En effet, si vous choisissez comme question secr\u00e8te \u00ab Quel est le nom de jeune-fille de ma m\u00e8re ? \u00bb la r\u00e9ponse peut \u00eatre tr\u00e8s facile \u00e0 trouver par un attaquant, le risque de d\u00e9couverte de votre mot de passe sera donc plus grand. La deuxi\u00e8me cat\u00e9gorie regroupe les facteurs de possession c\u2019est-\u00e0-dire les preuves qui correspondent \u00e0 \u00ab ce que je poss\u00e8de \u00bb. Dans nos activit\u00e9s professionnelles, il peut s\u2019agir de : Un t\u00e9l\u00e9phone portable (ex : un code \u00e0 usage unique envoy\u00e9 par SMS). Une carte \u00e0 puce (ex : carte bancaire, passeport \u00e9lectronique, carte vitale). Un badge, une cl\u00e9 USB de s\u00e9curit\u00e9. Un g\u00e9n\u00e9rateur de mot de passe \u00e0 usage unique (ex : certaines banques fournissent un bo\u00eetier pour valider des op\u00e9rations bancaires comme les virements), etc. Enfin, la troisi\u00e8me cat\u00e9gorie regroupe les preuves qui correspondent \u00e0 \u00ab ce que je suis \u00bb. Il s\u2019agit d\u2019 \u00e9l\u00e9ments biom\u00e9triques (ou inh\u00e9rents) tels que : Une empreinte digitale. Une empreinte r\u00e9tinienne. La structure de la main. La structure du visage. La voix. etc. L'avantage de cette m\u00e9thode est que l'utilisateur a toujours sur lui ses \u00ab codes d'authentification \u00bb et ne peut pas les perdre ou les oublier. Cependant, \u00e0 l\u2019inverse d\u2019un facteur de connaissance ou de possession, les \u00e9l\u00e9ments biom\u00e9triques sont fixes, ce qui peut poser des probl\u00e8mes vis \u00e0 vis de la vie priv\u00e9e.","title":"OBJECTIFS"},{"location":"Cybersecurite/authentification/#1-facteur-authentification-simple","text":"L'authentification \u00e9lectronique par identifiant et mot de passe met en \u0153uvre un unique facteur d'authentification, \u00e0 savoir le mot de passe qui rentre dans la cat\u00e9gorie des facteurs de connaissance : on parle alors d'authentification simple.","title":"1 FACTEUR = AUTHENTIFICATION SIMPLE"},{"location":"Cybersecurite/authentification/#plusieurs-facteurs-authentification-forte","text":"Lorsque le m\u00e9canisme d'authentification met en \u0153uvre plusieurs facteurs d'authentification, on parle alors d'authentification forte. L\u2019authentification forte m\u00eale ainsi diff\u00e9rents types de facteurs d\u2019authentification comme la connaissance associ\u00e9e \u00e0 la possession. Ce type d'authentification est souvent utilis\u00e9 pour se prot\u00e9ger des faiblesses pouvant \u00eatre li\u00e9es aux mots de passe. Aujourd\u2019hui, il est en effet assez r\u00e9pandu de pouvoir activer un deuxi\u00e8me facteur d'authentification pour acc\u00e9der \u00e0 sa messagerie \u00e9lectronique et de devoir saisir un code re\u00e7u par SMS apr\u00e8s avoir entr\u00e9 son mot de passe.","title":"PLUSIEURS FACTEURS = AUTHENTIFICATION FORTE"},{"location":"Cybersecurite/authentification/#limites-des-facteurs-dauthentification","text":"","title":"Limites des facteurs d'authentification"},{"location":"Cybersecurite/authentification/#la-biometrie","text":"De toutes les m\u00e9thodes d\u2019authentification vues ensemble, aujourd\u2019hui, la biom\u00e9trie est sans doute la m\u00e9thode la plus prometteuse, mais aussi la plus d\u00e9licate \u00e0 mettre en \u0153uvre pour plusieurs raisons.","title":"LA BIOM\u00c9TRIE"},{"location":"Cybersecurite/authentification/#limites-de-la-biometrie","text":"Il existe toutefois plusieurs limites \u00e0 la biom\u00e9trie. Tout d'abord, la biom\u00e9trie co\u00fbte cher et n\u00e9cessite de lourds moyens pour \u00eatre mise en place. Ensuite, elle pose des probl\u00e8mes sur l'aspect juridique du fait de stocker les caract\u00e9ristiques morphologiques des personnes. Notez \u00e9galement que certaines techniques d'authentification biom\u00e9triques sont plus susceptibles d'\u00eatre contourn\u00e9es que d'autres. Par exemple, les techniques courantes de reconnaissance du visage peuvent \u00eatre mises \u00e0 mal par une simple photo. Et c\u2019est sans compter les \u00e9ventuels probl\u00e8mes d\u2019acc\u00e8s qui pourraient survenir avec une voix enrou\u00e9e ou encore des mains br\u00fbl\u00e9es\u2026 L'un des axes de recherche de la biom\u00e9trie porte donc sur la multimodalit\u00e9 , c'est-\u00e0-dire la combinaison de plusieurs m\u00e9thodes d'identification par voie biom\u00e9trique. L\u00e0 encore les co\u00fbts restent aujourd\u2019hui un facteur limitant pour sa mise en place .","title":"LIMITES DE LA BIOM\u00c9TRIE"},{"location":"Cybersecurite/authentification/#exemple-en-belgique","text":"Il est important de noter que ce syst\u00e8me connait \u00e9galement quelques d\u00e9rives \u00e0 la crois\u00e9e entre les facteurs de possession et biom\u00e9trique . En Belgique par exemple, certains employ\u00e9s ont accept\u00e9 de se faire implanter des puces sous la peau . Notons toutefois que ce type de solutions a peu de chance de voir le jour en France puisqu\u2019il est, entre autres, contraire \u00e0 l\u2019application du r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es personnelles (RGPD) . En effet, ces bases de donn\u00e9es sont \u00e0 rapprocher de celles utilis\u00e9es par la police et sont donc soumises \u00e0 des lois tr\u00e8s strictes.","title":"EXEMPLE EN BELGIQUE"},{"location":"Cybersecurite/authentification/#les-risques-lies-aux-mots-de-passe","text":"","title":"Les risques li\u00e9s aux mots de passe"},{"location":"Cybersecurite/authentification/#presentation","text":"Le mot de passe est aujourd\u2019hui le mode d\u2019authentification le plus r\u00e9pandu . En effet, c\u2019est le mode d\u2019authentification le plus simple \u00e0 mettre en place sur nos services quotidiens. Mais ce mot de passe n\u2019est pas exempt de risques .","title":"Pr\u00e9sentation"},{"location":"Cybersecurite/authentification/#divulgation","text":"M\u00eame s\u2019il n\u2019\u00e9limine pas l\u2019ensemble des risques, le principe d'authentification permet toutefois de r\u00e9duire les risques d'usurpation d'identit\u00e9. Les risques peuvent varier en fonction du type d'authentification et de la nature des preuves apport\u00e9es. En particulier, un mot de passe est un \u00e9l\u00e9ment secret que vous seul devez conna\u00eetre car il conditionne l'acc\u00e8s \u00e0 vos donn\u00e9es et services en ligne. Le risque principal li\u00e9 \u00e0 son utilisation est donc sa divulgation \u00e0 un tiers qui pourrait en faire un usage malveillant. Les causes de divulgation peuvent \u00eatre multiples, de la n\u00e9gligence \u00e0 la malveillance.","title":"Divulgation"},{"location":"Cybersecurite/authentification/#negligeance","text":"On parle de divulgation par n\u00e9gligence dans les cas suivants : Utilisation d'un mot de passe faible (ex : 0000, 123456, motdepasse) ; Inscription du mot de passe sur un support accessible \u00e0 un tiers (post-it sous le clavier, tableau blanc, etc.) ; Diffusion \u00e0 un tiers (coll\u00e8gue, ami, op\u00e9rateur de service informatique, mot de passe envoy\u00e9 par email, etc.) oralement ou par \u00e9crit (papier, mail, etc.) ; Authentification sur un service via un protocole non s\u00e9curis\u00e9 tels que HTTP, IMAP, POP3, etc. au lieu de HTTPS, IMAPS, POPS ; Utilisation d'un ordinateur/smartphone qui ne soit pas de confiance et potentiellement infect\u00e9 (cybercaf\u00e9, ordinateur en libre acc\u00e8s dans un h\u00f4tel, etc.) ; Mot de passe enregistr\u00e9 sur le navigateur internet sans protection .","title":"N\u00e9gligeance"},{"location":"Cybersecurite/authentification/#malveillance","text":"La divulgation de mot de passe peut \u00e9galement faire suite \u00e0 un acte de malveillance. Il peut s\u2019agir : D\u2019une authentification sur un service ill\u00e9gitime (hame\u00e7onnage ou phishing, dont on parlera dans l\u2019unit\u00e9 2 de ce module) D\u2018une attaque par ing\u00e9nierie sociale (utilisation de vos donn\u00e9es personnelles pour vous pi\u00e9ger) D\u2019une attaque par force brute ou de la divulgation d\u2019une base de donn\u00e9es de mots de passe d\u2019un service mal s\u00e9curis\u00e9.","title":"Malveillance"},{"location":"Cybersecurite/authentification/#ces-differentes-causes-de-divulgation-seront-abordees-en-detail-dans-la-suite-de-ce-cours","text":"Gardez en t\u00eate que lorsque votre mot de passe a \u00e9t\u00e9 divulgu\u00e9, il perd son caract\u00e8re confidentiel . Un individu malveillant peut alors usurper votre identit\u00e9 sur un service en ligne et effectuer des actions en votre nom. Les cons\u00e9quences varient en fonction du type de service impact\u00e9 et des objectifs des individus malveillants : Compromission de messages personnels sur votre messagerie \u00e9lectronique ; Destruction de donn\u00e9es ; Publication de messages ou photos pr\u00e9judiciables sur vos r\u00e9seaux sociaux ; Achats sur des sites de vente en ligne (certains sites proposent en effet de conserver votre num\u00e9ro de carte bancaire) ; Virements bancaires sur le site de votre banque, etc. ;","title":"Ces diff\u00e9rentes causes de divulgation seront abord\u00e9es en d\u00e9tail dans la suite de ce cours."},{"location":"Cybersecurite/authentification/#conclusion","text":"L'usurpation d'identit\u00e9 peut avoir des cons\u00e9quences importantes pour vous et par extension pour votre entreprise . C\u2019est pourquoi, si vous \u00eates victime d'usurpation d'identit\u00e9, il est n\u00e9cessaire de suivre les conseils suivants : Pour limiter ces risques, il convient d'appliquer un certain nombre de bonnes pratiques que vous d\u00e9couvrirez dans la suite de votre parcours.","title":"Conclusion"},{"location":"Cybersecurite/authentification_principes/","text":"Les principes de l'authentification Introduction Avec la multiplication des services en ligne (messagerie, sites marchands, h\u00e9bergement de documents, r\u00e9seaux sociaux, etc.), nous devons aujourd\u2019hui g\u00e9rer de nombreux mots de passe. En obtenant le mot de passe d\u2019une personne, l\u2019attaquant prend possession du moyen d\u2019acc\u00e9der \u00e0 des services et informations utiles. Un v\u00e9ritable s\u00e9same pour une personne malveillante ! Comment les choisir ? Comment les retenir ? Quels sont les risques en cas de vol de mot de passe et que faire ? Dans cette unit\u00e9, nous allons tenter de r\u00e9pondre \u00e0 quelques-unes de ces questions et de vous donner quelques bonnes pratiques \u00e0 adopter. Objectif de l'authentification Lorsque vous vous connectez sur un service, il vous est demand\u00e9 de vous authentifier . Pour cela on vous demande g\u00e9n\u00e9ralement de communiquer un nom d'utilisateur (l'identit\u00e9) et un mot de passe. L\u2019authentification est une \u00e9tape de contr\u00f4le indispensable puisqu\u2019elle vise \u00e0 v\u00e9rifier l\u2019identit\u00e9 communiqu\u00e9e par un utilisateur lors de sa connexion sur un service. Le principe d'authentification est une brique essentielle pour permettre la mise en place des m\u00e9canismes de s\u00e9curit\u00e9 des services en ligne. C'est le cas notamment du contr\u00f4le des acc\u00e8s , qui permet de g\u00e9rer les autorisations pour acc\u00e9der \u00e0 vos donn\u00e9es en s'appuyant sur l'identit\u00e9 authentifi\u00e9e. Pour acc\u00e9der \u00e0 vos donn\u00e9es, deux principes diff\u00e9rents sont ainsi mis en \u0153uvre : le principe d'authentification et le principe d'autorisation. Par exemple, lorsque vous avez saisi votre identifiant et votre mot de passe sur votre service de messagerie en ligne ( principe d'authentification ), vous pouvez consulter vos propres messages mais pas ceux re\u00e7us par d'autres utilisateurs (principe d'autorisation). Et inversement, ces autres utilisateurs ne peuvent pas consulter vos messages. OBJECTIFS Le principe d'authentification est \u00e9galement utilis\u00e9 pour assurer l'imputabilit\u00e9 (c\u2019est-\u00e0-dire pour apporter la preuve de qui a fait quoi) et la tra\u00e7abilit\u00e9 des actions (c\u2019est-\u00e0-dire conserver l'historique des actions). Ainsi, lorsque vous t\u00e9l\u00e9-d\u00e9clarez vos imp\u00f4ts en ligne par exemple, l'imputabilit\u00e9 permet de faire le lien entre votre d\u00e9claration et votre identit\u00e9 authentifi\u00e9e. La tra\u00e7abilit\u00e9, quant \u00e0 elle, permet de conna\u00eetre l'heure \u00e0 laquelle vous avez soumis votre d\u00e9claration d'imp\u00f4ts. Facteurs de l'authentification OBJECTIFS L'authentification consiste \u00e0 apporter la preuve de son identit\u00e9 mais il existe plusieurs fa\u00e7ons de la prouver. Celles-ci se r\u00e9partissent en plusieurs cat\u00e9gories : on parle de facteurs d'authentification . Les diff\u00e9rents facteurs sont la connaissance, la possession ou encore les caract\u00e9ristiques biom\u00e9triques . Les facteurs de connaissance sont aujourd\u2019hui la cat\u00e9gorie la plus r\u00e9pandue. Cette cat\u00e9gorie regroupe les preuves correspondant \u00e0 \u00ab ce que je connais \u00bb. Ces preuves peuvent \u00eatre par exemple : Un mot de passe. Un code PIN de carte \u00e0 puce (ex : un code de carte bancaire). La r\u00e9ponse \u00e0 une question secr\u00e8te et connue de vous seul(e). Un sch\u00e9ma de d\u00e9verrouillage (ex : d\u00e9verrouillage des smartphones). Soyez vigilant lorsque vous d\u00e9finissez des mots de passe. Vous devez faire attention \u00e0 d\u00e9finir des mots de passe complexes (dont on parlera dans l\u2019unit\u00e9 3 de ce module), et \u00e0 vous assurer que les r\u00e9ponses \u00e0 vos questions secr\u00e8tes ne sont pas trivialement retrouvables. En effet, si vous choisissez comme question secr\u00e8te \u00ab Quel est le nom de jeune-fille de ma m\u00e8re ? \u00bb la r\u00e9ponse peut \u00eatre tr\u00e8s facile \u00e0 trouver par un attaquant, le risque de d\u00e9couverte de votre mot de passe sera donc plus grand. La deuxi\u00e8me cat\u00e9gorie regroupe les facteurs de possession c\u2019est-\u00e0-dire les preuves qui correspondent \u00e0 \u00ab ce que je poss\u00e8de \u00bb. Dans nos activit\u00e9s professionnelles, il peut s\u2019agir de : Un t\u00e9l\u00e9phone portable (ex : un code \u00e0 usage unique envoy\u00e9 par SMS). Une carte \u00e0 puce (ex : carte bancaire, passeport \u00e9lectronique, carte vitale). Un badge, une cl\u00e9 USB de s\u00e9curit\u00e9. Un g\u00e9n\u00e9rateur de mot de passe \u00e0 usage unique (ex : certaines banques fournissent un bo\u00eetier pour valider des op\u00e9rations bancaires comme les virements), etc. Enfin, la troisi\u00e8me cat\u00e9gorie regroupe les preuves qui correspondent \u00e0 \u00ab ce que je suis \u00bb. Il s\u2019agit d\u2019 \u00e9l\u00e9ments biom\u00e9triques (ou inh\u00e9rents) tels que : Une empreinte digitale. Une empreinte r\u00e9tinienne. La structure de la main. La structure du visage. La voix. etc. L'avantage de cette m\u00e9thode est que l'utilisateur a toujours sur lui ses \u00ab codes d'authentification \u00bb et ne peut pas les perdre ou les oublier. Cependant, \u00e0 l\u2019inverse d\u2019un facteur de connaissance ou de possession, les \u00e9l\u00e9ments biom\u00e9triques sont fixes, ce qui peut poser des probl\u00e8mes vis \u00e0 vis de la vie priv\u00e9e. 1 FACTEUR = AUTHENTIFICATION SIMPLE L'authentification \u00e9lectronique par identifiant et mot de passe met en \u0153uvre un unique facteur d'authentification, \u00e0 savoir le mot de passe qui rentre dans la cat\u00e9gorie des facteurs de connaissance : on parle alors d'authentification simple. PLUSIEURS FACTEURS = AUTHENTIFICATION FORTE Lorsque le m\u00e9canisme d'authentification met en \u0153uvre plusieurs facteurs d'authentification, on parle alors d'authentification forte. L\u2019authentification forte m\u00eale ainsi diff\u00e9rents types de facteurs d\u2019authentification comme la connaissance associ\u00e9e \u00e0 la possession. Ce type d'authentification est souvent utilis\u00e9 pour se prot\u00e9ger des faiblesses pouvant \u00eatre li\u00e9es aux mots de passe. Aujourd\u2019hui, il est en effet assez r\u00e9pandu de pouvoir activer un deuxi\u00e8me facteur d'authentification pour acc\u00e9der \u00e0 sa messagerie \u00e9lectronique et de devoir saisir un code re\u00e7u par SMS apr\u00e8s avoir entr\u00e9 son mot de passe. Limites des facteurs d'authentification LA BIOM\u00c9TRIE De toutes les m\u00e9thodes d\u2019authentification vues ensemble, aujourd\u2019hui, la biom\u00e9trie est sans doute la m\u00e9thode la plus prometteuse, mais aussi la plus d\u00e9licate \u00e0 mettre en \u0153uvre pour plusieurs raisons. LIMITES DE LA BIOM\u00c9TRIE Il existe toutefois plusieurs limites \u00e0 la biom\u00e9trie. Tout d'abord, la biom\u00e9trie co\u00fbte cher et n\u00e9cessite de lourds moyens pour \u00eatre mise en place. Ensuite, elle pose des probl\u00e8mes sur l'aspect juridique du fait de stocker les caract\u00e9ristiques morphologiques des personnes. Notez \u00e9galement que certaines techniques d'authentification biom\u00e9triques sont plus susceptibles d'\u00eatre contourn\u00e9es que d'autres. Par exemple, les techniques courantes de reconnaissance du visage peuvent \u00eatre mises \u00e0 mal par une simple photo. Et c\u2019est sans compter les \u00e9ventuels probl\u00e8mes d\u2019acc\u00e8s qui pourraient survenir avec une voix enrou\u00e9e ou encore des mains br\u00fbl\u00e9es\u2026 L'un des axes de recherche de la biom\u00e9trie porte donc sur la multimodalit\u00e9 , c'est-\u00e0-dire la combinaison de plusieurs m\u00e9thodes d'identification par voie biom\u00e9trique. L\u00e0 encore les co\u00fbts restent aujourd\u2019hui un facteur limitant pour sa mise en place . EXEMPLE EN BELGIQUE Il est important de noter que ce syst\u00e8me connait \u00e9galement quelques d\u00e9rives \u00e0 la crois\u00e9e entre les facteurs de possession et biom\u00e9trique . En Belgique par exemple, certains employ\u00e9s ont accept\u00e9 de se faire implanter des puces sous la peau . Notons toutefois que ce type de solutions a peu de chance de voir le jour en France puisqu\u2019il est, entre autres, contraire \u00e0 l\u2019application du r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es personnelles (RGPD) . En effet, ces bases de donn\u00e9es sont \u00e0 rapprocher de celles utilis\u00e9es par la police et sont donc soumises \u00e0 des lois tr\u00e8s strictes. Les risques li\u00e9s aux mots de passe Pr\u00e9sentation Le mot de passe est aujourd\u2019hui le mode d\u2019authentification le plus r\u00e9pandu . En effet, c\u2019est le mode d\u2019authentification le plus simple \u00e0 mettre en place sur nos services quotidiens. Mais ce mot de passe n\u2019est pas exempt de risques . Divulgation M\u00eame s\u2019il n\u2019\u00e9limine pas l\u2019ensemble des risques, le principe d'authentification permet toutefois de r\u00e9duire les risques d'usurpation d'identit\u00e9. Les risques peuvent varier en fonction du type d'authentification et de la nature des preuves apport\u00e9es. En particulier, un mot de passe est un \u00e9l\u00e9ment secret que vous seul devez conna\u00eetre car il conditionne l'acc\u00e8s \u00e0 vos donn\u00e9es et services en ligne. Le risque principal li\u00e9 \u00e0 son utilisation est donc sa divulgation \u00e0 un tiers qui pourrait en faire un usage malveillant. Les causes de divulgation peuvent \u00eatre multiples, de la n\u00e9gligence \u00e0 la malveillance. N\u00e9gligeance On parle de divulgation par n\u00e9gligence dans les cas suivants : Utilisation d'un mot de passe faible (ex : 0000, 123456, motdepasse) ; Inscription du mot de passe sur un support accessible \u00e0 un tiers (post-it sous le clavier, tableau blanc, etc.) ; Diffusion \u00e0 un tiers (coll\u00e8gue, ami, op\u00e9rateur de service informatique, mot de passe envoy\u00e9 par email, etc.) oralement ou par \u00e9crit (papier, mail, etc.) ; Authentification sur un service via un protocole non s\u00e9curis\u00e9 tels que HTTP, IMAP, POP3, etc. au lieu de HTTPS, IMAPS, POPS ; Utilisation d'un ordinateur/smartphone qui ne soit pas de confiance et potentiellement infect\u00e9 (cybercaf\u00e9, ordinateur en libre acc\u00e8s dans un h\u00f4tel, etc.) ; Mot de passe enregistr\u00e9 sur le navigateur internet sans protection . Malveillance La divulgation de mot de passe peut \u00e9galement faire suite \u00e0 un acte de malveillance. Il peut s\u2019agir : D\u2019une authentification sur un service ill\u00e9gitime (hame\u00e7onnage ou phishing, dont on parlera dans l\u2019unit\u00e9 2 de ce module) D\u2018une attaque par ing\u00e9nierie sociale (utilisation de vos donn\u00e9es personnelles pour vous pi\u00e9ger) D\u2019une attaque par force brute ou de la divulgation d\u2019une base de donn\u00e9es de mots de passe d\u2019un service mal s\u00e9curis\u00e9. Ces diff\u00e9rentes causes de divulgation seront abord\u00e9es en d\u00e9tail dans la suite de ce cours. Gardez en t\u00eate que lorsque votre mot de passe a \u00e9t\u00e9 divulgu\u00e9, il perd son caract\u00e8re confidentiel . Un individu malveillant peut alors usurper votre identit\u00e9 sur un service en ligne et effectuer des actions en votre nom. Les cons\u00e9quences varient en fonction du type de service impact\u00e9 et des objectifs des individus malveillants : Compromission de messages personnels sur votre messagerie \u00e9lectronique ; Destruction de donn\u00e9es ; Publication de messages ou photos pr\u00e9judiciables sur vos r\u00e9seaux sociaux ; Achats sur des sites de vente en ligne (certains sites proposent en effet de conserver votre num\u00e9ro de carte bancaire) ; Virements bancaires sur le site de votre banque, etc. ; Conclusion L'usurpation d'identit\u00e9 peut avoir des cons\u00e9quences importantes pour vous et par extension pour votre entreprise . C\u2019est pourquoi, si vous \u00eates victime d'usurpation d'identit\u00e9, il est n\u00e9cessaire de suivre les conseils suivants : Pour limiter ces risques, il convient d'appliquer un certain nombre de bonnes pratiques que vous d\u00e9couvrirez dans la suite de votre parcours.","title":"Les principes de l'authentification"},{"location":"Cybersecurite/authentification_principes/#les-principes-de-lauthentification","text":"","title":"Les principes de l'authentification"},{"location":"Cybersecurite/authentification_principes/#introduction","text":"Avec la multiplication des services en ligne (messagerie, sites marchands, h\u00e9bergement de documents, r\u00e9seaux sociaux, etc.), nous devons aujourd\u2019hui g\u00e9rer de nombreux mots de passe. En obtenant le mot de passe d\u2019une personne, l\u2019attaquant prend possession du moyen d\u2019acc\u00e9der \u00e0 des services et informations utiles. Un v\u00e9ritable s\u00e9same pour une personne malveillante ! Comment les choisir ? Comment les retenir ? Quels sont les risques en cas de vol de mot de passe et que faire ? Dans cette unit\u00e9, nous allons tenter de r\u00e9pondre \u00e0 quelques-unes de ces questions et de vous donner quelques bonnes pratiques \u00e0 adopter.","title":"Introduction"},{"location":"Cybersecurite/authentification_principes/#objectif-de-lauthentification","text":"Lorsque vous vous connectez sur un service, il vous est demand\u00e9 de vous authentifier . Pour cela on vous demande g\u00e9n\u00e9ralement de communiquer un nom d'utilisateur (l'identit\u00e9) et un mot de passe. L\u2019authentification est une \u00e9tape de contr\u00f4le indispensable puisqu\u2019elle vise \u00e0 v\u00e9rifier l\u2019identit\u00e9 communiqu\u00e9e par un utilisateur lors de sa connexion sur un service. Le principe d'authentification est une brique essentielle pour permettre la mise en place des m\u00e9canismes de s\u00e9curit\u00e9 des services en ligne. C'est le cas notamment du contr\u00f4le des acc\u00e8s , qui permet de g\u00e9rer les autorisations pour acc\u00e9der \u00e0 vos donn\u00e9es en s'appuyant sur l'identit\u00e9 authentifi\u00e9e. Pour acc\u00e9der \u00e0 vos donn\u00e9es, deux principes diff\u00e9rents sont ainsi mis en \u0153uvre : le principe d'authentification et le principe d'autorisation. Par exemple, lorsque vous avez saisi votre identifiant et votre mot de passe sur votre service de messagerie en ligne ( principe d'authentification ), vous pouvez consulter vos propres messages mais pas ceux re\u00e7us par d'autres utilisateurs (principe d'autorisation). Et inversement, ces autres utilisateurs ne peuvent pas consulter vos messages.","title":"Objectif de l'authentification"},{"location":"Cybersecurite/authentification_principes/#objectifs","text":"Le principe d'authentification est \u00e9galement utilis\u00e9 pour assurer l'imputabilit\u00e9 (c\u2019est-\u00e0-dire pour apporter la preuve de qui a fait quoi) et la tra\u00e7abilit\u00e9 des actions (c\u2019est-\u00e0-dire conserver l'historique des actions). Ainsi, lorsque vous t\u00e9l\u00e9-d\u00e9clarez vos imp\u00f4ts en ligne par exemple, l'imputabilit\u00e9 permet de faire le lien entre votre d\u00e9claration et votre identit\u00e9 authentifi\u00e9e. La tra\u00e7abilit\u00e9, quant \u00e0 elle, permet de conna\u00eetre l'heure \u00e0 laquelle vous avez soumis votre d\u00e9claration d'imp\u00f4ts.","title":"OBJECTIFS"},{"location":"Cybersecurite/authentification_principes/#facteurs-de-lauthentification","text":"","title":"Facteurs de l'authentification"},{"location":"Cybersecurite/authentification_principes/#objectifs_1","text":"L'authentification consiste \u00e0 apporter la preuve de son identit\u00e9 mais il existe plusieurs fa\u00e7ons de la prouver. Celles-ci se r\u00e9partissent en plusieurs cat\u00e9gories : on parle de facteurs d'authentification . Les diff\u00e9rents facteurs sont la connaissance, la possession ou encore les caract\u00e9ristiques biom\u00e9triques . Les facteurs de connaissance sont aujourd\u2019hui la cat\u00e9gorie la plus r\u00e9pandue. Cette cat\u00e9gorie regroupe les preuves correspondant \u00e0 \u00ab ce que je connais \u00bb. Ces preuves peuvent \u00eatre par exemple : Un mot de passe. Un code PIN de carte \u00e0 puce (ex : un code de carte bancaire). La r\u00e9ponse \u00e0 une question secr\u00e8te et connue de vous seul(e). Un sch\u00e9ma de d\u00e9verrouillage (ex : d\u00e9verrouillage des smartphones). Soyez vigilant lorsque vous d\u00e9finissez des mots de passe. Vous devez faire attention \u00e0 d\u00e9finir des mots de passe complexes (dont on parlera dans l\u2019unit\u00e9 3 de ce module), et \u00e0 vous assurer que les r\u00e9ponses \u00e0 vos questions secr\u00e8tes ne sont pas trivialement retrouvables. En effet, si vous choisissez comme question secr\u00e8te \u00ab Quel est le nom de jeune-fille de ma m\u00e8re ? \u00bb la r\u00e9ponse peut \u00eatre tr\u00e8s facile \u00e0 trouver par un attaquant, le risque de d\u00e9couverte de votre mot de passe sera donc plus grand. La deuxi\u00e8me cat\u00e9gorie regroupe les facteurs de possession c\u2019est-\u00e0-dire les preuves qui correspondent \u00e0 \u00ab ce que je poss\u00e8de \u00bb. Dans nos activit\u00e9s professionnelles, il peut s\u2019agir de : Un t\u00e9l\u00e9phone portable (ex : un code \u00e0 usage unique envoy\u00e9 par SMS). Une carte \u00e0 puce (ex : carte bancaire, passeport \u00e9lectronique, carte vitale). Un badge, une cl\u00e9 USB de s\u00e9curit\u00e9. Un g\u00e9n\u00e9rateur de mot de passe \u00e0 usage unique (ex : certaines banques fournissent un bo\u00eetier pour valider des op\u00e9rations bancaires comme les virements), etc. Enfin, la troisi\u00e8me cat\u00e9gorie regroupe les preuves qui correspondent \u00e0 \u00ab ce que je suis \u00bb. Il s\u2019agit d\u2019 \u00e9l\u00e9ments biom\u00e9triques (ou inh\u00e9rents) tels que : Une empreinte digitale. Une empreinte r\u00e9tinienne. La structure de la main. La structure du visage. La voix. etc. L'avantage de cette m\u00e9thode est que l'utilisateur a toujours sur lui ses \u00ab codes d'authentification \u00bb et ne peut pas les perdre ou les oublier. Cependant, \u00e0 l\u2019inverse d\u2019un facteur de connaissance ou de possession, les \u00e9l\u00e9ments biom\u00e9triques sont fixes, ce qui peut poser des probl\u00e8mes vis \u00e0 vis de la vie priv\u00e9e.","title":"OBJECTIFS"},{"location":"Cybersecurite/authentification_principes/#1-facteur-authentification-simple","text":"L'authentification \u00e9lectronique par identifiant et mot de passe met en \u0153uvre un unique facteur d'authentification, \u00e0 savoir le mot de passe qui rentre dans la cat\u00e9gorie des facteurs de connaissance : on parle alors d'authentification simple.","title":"1 FACTEUR = AUTHENTIFICATION SIMPLE"},{"location":"Cybersecurite/authentification_principes/#plusieurs-facteurs-authentification-forte","text":"Lorsque le m\u00e9canisme d'authentification met en \u0153uvre plusieurs facteurs d'authentification, on parle alors d'authentification forte. L\u2019authentification forte m\u00eale ainsi diff\u00e9rents types de facteurs d\u2019authentification comme la connaissance associ\u00e9e \u00e0 la possession. Ce type d'authentification est souvent utilis\u00e9 pour se prot\u00e9ger des faiblesses pouvant \u00eatre li\u00e9es aux mots de passe. Aujourd\u2019hui, il est en effet assez r\u00e9pandu de pouvoir activer un deuxi\u00e8me facteur d'authentification pour acc\u00e9der \u00e0 sa messagerie \u00e9lectronique et de devoir saisir un code re\u00e7u par SMS apr\u00e8s avoir entr\u00e9 son mot de passe.","title":"PLUSIEURS FACTEURS = AUTHENTIFICATION FORTE"},{"location":"Cybersecurite/authentification_principes/#limites-des-facteurs-dauthentification","text":"","title":"Limites des facteurs d'authentification"},{"location":"Cybersecurite/authentification_principes/#la-biometrie","text":"De toutes les m\u00e9thodes d\u2019authentification vues ensemble, aujourd\u2019hui, la biom\u00e9trie est sans doute la m\u00e9thode la plus prometteuse, mais aussi la plus d\u00e9licate \u00e0 mettre en \u0153uvre pour plusieurs raisons.","title":"LA BIOM\u00c9TRIE"},{"location":"Cybersecurite/authentification_principes/#limites-de-la-biometrie","text":"Il existe toutefois plusieurs limites \u00e0 la biom\u00e9trie. Tout d'abord, la biom\u00e9trie co\u00fbte cher et n\u00e9cessite de lourds moyens pour \u00eatre mise en place. Ensuite, elle pose des probl\u00e8mes sur l'aspect juridique du fait de stocker les caract\u00e9ristiques morphologiques des personnes. Notez \u00e9galement que certaines techniques d'authentification biom\u00e9triques sont plus susceptibles d'\u00eatre contourn\u00e9es que d'autres. Par exemple, les techniques courantes de reconnaissance du visage peuvent \u00eatre mises \u00e0 mal par une simple photo. Et c\u2019est sans compter les \u00e9ventuels probl\u00e8mes d\u2019acc\u00e8s qui pourraient survenir avec une voix enrou\u00e9e ou encore des mains br\u00fbl\u00e9es\u2026 L'un des axes de recherche de la biom\u00e9trie porte donc sur la multimodalit\u00e9 , c'est-\u00e0-dire la combinaison de plusieurs m\u00e9thodes d'identification par voie biom\u00e9trique. L\u00e0 encore les co\u00fbts restent aujourd\u2019hui un facteur limitant pour sa mise en place .","title":"LIMITES DE LA BIOM\u00c9TRIE"},{"location":"Cybersecurite/authentification_principes/#exemple-en-belgique","text":"Il est important de noter que ce syst\u00e8me connait \u00e9galement quelques d\u00e9rives \u00e0 la crois\u00e9e entre les facteurs de possession et biom\u00e9trique . En Belgique par exemple, certains employ\u00e9s ont accept\u00e9 de se faire implanter des puces sous la peau . Notons toutefois que ce type de solutions a peu de chance de voir le jour en France puisqu\u2019il est, entre autres, contraire \u00e0 l\u2019application du r\u00e8glement g\u00e9n\u00e9ral sur la protection des donn\u00e9es personnelles (RGPD) . En effet, ces bases de donn\u00e9es sont \u00e0 rapprocher de celles utilis\u00e9es par la police et sont donc soumises \u00e0 des lois tr\u00e8s strictes.","title":"EXEMPLE EN BELGIQUE"},{"location":"Cybersecurite/authentification_principes/#les-risques-lies-aux-mots-de-passe","text":"","title":"Les risques li\u00e9s aux mots de passe"},{"location":"Cybersecurite/authentification_principes/#presentation","text":"Le mot de passe est aujourd\u2019hui le mode d\u2019authentification le plus r\u00e9pandu . En effet, c\u2019est le mode d\u2019authentification le plus simple \u00e0 mettre en place sur nos services quotidiens. Mais ce mot de passe n\u2019est pas exempt de risques .","title":"Pr\u00e9sentation"},{"location":"Cybersecurite/authentification_principes/#divulgation","text":"M\u00eame s\u2019il n\u2019\u00e9limine pas l\u2019ensemble des risques, le principe d'authentification permet toutefois de r\u00e9duire les risques d'usurpation d'identit\u00e9. Les risques peuvent varier en fonction du type d'authentification et de la nature des preuves apport\u00e9es. En particulier, un mot de passe est un \u00e9l\u00e9ment secret que vous seul devez conna\u00eetre car il conditionne l'acc\u00e8s \u00e0 vos donn\u00e9es et services en ligne. Le risque principal li\u00e9 \u00e0 son utilisation est donc sa divulgation \u00e0 un tiers qui pourrait en faire un usage malveillant. Les causes de divulgation peuvent \u00eatre multiples, de la n\u00e9gligence \u00e0 la malveillance.","title":"Divulgation"},{"location":"Cybersecurite/authentification_principes/#negligeance","text":"On parle de divulgation par n\u00e9gligence dans les cas suivants : Utilisation d'un mot de passe faible (ex : 0000, 123456, motdepasse) ; Inscription du mot de passe sur un support accessible \u00e0 un tiers (post-it sous le clavier, tableau blanc, etc.) ; Diffusion \u00e0 un tiers (coll\u00e8gue, ami, op\u00e9rateur de service informatique, mot de passe envoy\u00e9 par email, etc.) oralement ou par \u00e9crit (papier, mail, etc.) ; Authentification sur un service via un protocole non s\u00e9curis\u00e9 tels que HTTP, IMAP, POP3, etc. au lieu de HTTPS, IMAPS, POPS ; Utilisation d'un ordinateur/smartphone qui ne soit pas de confiance et potentiellement infect\u00e9 (cybercaf\u00e9, ordinateur en libre acc\u00e8s dans un h\u00f4tel, etc.) ; Mot de passe enregistr\u00e9 sur le navigateur internet sans protection .","title":"N\u00e9gligeance"},{"location":"Cybersecurite/authentification_principes/#malveillance","text":"La divulgation de mot de passe peut \u00e9galement faire suite \u00e0 un acte de malveillance. Il peut s\u2019agir : D\u2019une authentification sur un service ill\u00e9gitime (hame\u00e7onnage ou phishing, dont on parlera dans l\u2019unit\u00e9 2 de ce module) D\u2018une attaque par ing\u00e9nierie sociale (utilisation de vos donn\u00e9es personnelles pour vous pi\u00e9ger) D\u2019une attaque par force brute ou de la divulgation d\u2019une base de donn\u00e9es de mots de passe d\u2019un service mal s\u00e9curis\u00e9.","title":"Malveillance"},{"location":"Cybersecurite/authentification_principes/#ces-differentes-causes-de-divulgation-seront-abordees-en-detail-dans-la-suite-de-ce-cours","text":"Gardez en t\u00eate que lorsque votre mot de passe a \u00e9t\u00e9 divulgu\u00e9, il perd son caract\u00e8re confidentiel . Un individu malveillant peut alors usurper votre identit\u00e9 sur un service en ligne et effectuer des actions en votre nom. Les cons\u00e9quences varient en fonction du type de service impact\u00e9 et des objectifs des individus malveillants : Compromission de messages personnels sur votre messagerie \u00e9lectronique ; Destruction de donn\u00e9es ; Publication de messages ou photos pr\u00e9judiciables sur vos r\u00e9seaux sociaux ; Achats sur des sites de vente en ligne (certains sites proposent en effet de conserver votre num\u00e9ro de carte bancaire) ; Virements bancaires sur le site de votre banque, etc. ;","title":"Ces diff\u00e9rentes causes de divulgation seront abord\u00e9es en d\u00e9tail dans la suite de ce cours."},{"location":"Cybersecurite/authentification_principes/#conclusion","text":"L'usurpation d'identit\u00e9 peut avoir des cons\u00e9quences importantes pour vous et par extension pour votre entreprise . C\u2019est pourquoi, si vous \u00eates victime d'usurpation d'identit\u00e9, il est n\u00e9cessaire de suivre les conseils suivants : Pour limiter ces risques, il convient d'appliquer un certain nombre de bonnes pratiques que vous d\u00e9couvrirez dans la suite de votre parcours.","title":"Conclusion"},{"location":"Python/boucles/","text":"Boucles et comparaisons Boucles for Principe En programmation, on est souvent amen\u00e9 \u00e0 r\u00e9p\u00e9ter plusieurs fois une instruction. Incontournables \u00e0 tout langage de programmation, les boucles vont nous aider \u00e0 r\u00e9aliser cette t\u00e2che de mani\u00e8re compacte et efficace. Imaginez par exemple que vous souhaitiez afficher les \u00e9l\u00e9ments d'une liste les uns apr\u00e8s les autres. Dans l'\u00e9tat actuel de vos connaissances, il faudrait taper quelque chose du style : 1 2 3 4 5 animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] print ( animaux [ 0 ]) print ( animaux [ 1 ]) print ( animaux [ 2 ]) print ( animaux [ 3 ]) Si votre liste ne contient que 4 \u00e9l\u00e9ments, ceci est encore faisable mais imaginez qu'elle en contienne 100 voire 1000 ! Pour rem\u00e9dier \u00e0 cela, il faut utiliser les boucles. Regardez l'exemple suivant : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris La variable animal est appel\u00e9e variable d'it\u00e9ration , elle prend successivement les diff\u00e9rentes valeurs de la liste animaux \u00e0 chaque it\u00e9ration de la boucle. On verra un peu plus loin dans ce chapitre que l'on peut choisir le nom que l'on veut pour cette variable. Celle-ci est cr\u00e9\u00e9e par Python la premi\u00e8re fois que la ligne contenant le for est ex\u00e9cut\u00e9e (si elle existait d\u00e9j\u00e0 son contenu serait \u00e9cras\u00e9). Une fois la boucle termin\u00e9e, cette variable d'it\u00e9ration animal ne sera pas d\u00e9truite et contiendra ainsi la derni\u00e8re valeur de la liste animaux (ici la cha\u00eene de caract\u00e8res souris ). Notez bien les types des variables utilis\u00e9es ici : animaux est une liste sur laquelle on it\u00e8re, et animal est une cha\u00eene de caract\u00e8res car chaque \u00e9l\u00e9ment de la liste est une cha\u00eene de caract\u00e8res. Nous verrons plus loin que la variable d'it\u00e9ration peut \u00eatre de n'importe quel type selon la liste parcourue. En Python , une boucle it\u00e8re toujours sur un objet dit s\u00e9quentiel (c'est-\u00e0-dire un objet constitu\u00e9 d'autres objets) tel qu'une liste. Nous verrons aussi plus tard d'autres objets s\u00e9quentiels sur lesquels on peut it\u00e9rer dans une boucle. D'ores et d\u00e9j\u00e0, pr\u00eatez attention au caract\u00e8re deux-points \u00ab : \u00bb \u00e0 la fin de la ligne d\u00e9butant par for . Cela signifie que la boucle for attend un bloc d'instructions , en l\u2019occurrence toutes les instructions que Python r\u00e9p\u00e9tera \u00e0 chaque it\u00e9ration de la boucle. On appelle ce bloc d'instructions le corps de la boucle . Comment indique-t-on \u00e0 Python o\u00f9 ce bloc commence et se termine ? Cela est signal\u00e9 uniquement par l' indentation , c'est-\u00e0-dire le d\u00e9calage vers la droite de la (ou des) ligne(s) du bloc d'instructions. Dans l'exemple suivant, le corps de la boucle contient deux instructions : print(animal) et print(animal*2) car elles sont indent\u00e9es par rapport \u00e0 la ligne d\u00e9butant par for : 1 2 3 4 for animal in animaux : print ( animal ) print ( animal * 2 ) print ( \"C'est fini\" ) La ligne 4 print(\"C'est fini\") ne fait pas partie du corps de la boucle car elle est au m\u00eame niveau que le for (c'est-\u00e0-dire non indent\u00e9e par rapport au for ). Notez \u00e9galement que chaque instruction du corps de la boucle doit \u00eatre indent\u00e9e de la m\u00eame mani\u00e8re (ici 4 espaces). Remarque Outre une meilleure lisibilit\u00e9, les deux-points et l' indentation sont formellement requis en Python. M\u00eame si on peut indenter comme on veut (plusieurs espaces ou plusieurs tabulations, mais pas une combinaison des deux), les d\u00e9veloppeurs recommandent l'utilisation de quatre espaces. Vous pouvez consulter \u00e0 ce sujet le chapitre 15 Bonnes pratiques de programmation en Python . Faites en sorte de configurer votre \u00e9diteur de texte favori de fa\u00e7on \u00e0 \u00e9crire quatre espaces lorsque vous tapez sur la touche Tab (tabulation). Si on oublie l'indentation, Python renvoie un message d'erreur : 1 2 3 4 5 6 >>> for animal in animaux : ... print ( animal ) File \"<stdin>\" , line 2 print ( animal ) ^ IndentationError : expected an indented block Dans les exemples ci-dessus, nous avons ex\u00e9cut\u00e9 une boucle en it\u00e9rant directement sur une liste. Une tranche d'une liste \u00e9tant elle m\u00eame une liste, on peut \u00e9galement it\u00e9rer dessus : 1 2 3 4 5 6 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux [ 1 : 3 ]: ... print ( animal ) ... tigre singe On a vu que les boucles for pouvaient utiliser une liste contenant des cha\u00eenes de caract\u00e8res, mais elles peuvent tout aussi bien utiliser des listes contenant des entiers (ou n'importe quel type de variable). 1 2 3 4 5 6 >>> for i in [ 1 , 2 , 3 ]: ... print ( i ) ... 1 2 3 Fonction range() Python poss\u00e8de la fonction range() que nous avons rencontr\u00e9e pr\u00e9c\u00e9demment dans le chapitre 4 sur les Listes et qui est aussi bien commode pour faire une boucle sur une liste d'entiers de mani\u00e8re automatique : 1 2 3 4 5 6 7 >>> for i in range ( 4 ): ... print ( i ) ... 0 1 2 3 Dans cet exemple, nous pouvons faire plusieurs remarques importantes : Contrairement \u00e0 la cr\u00e9ation de liste avec list(range(4)) , la fonction range() peut \u00eatre utilis\u00e9e telle quelle dans une boucle. Il n'est pas n\u00e9cessaire de taper for i in list(range(4)): m\u00eame si cela fonctionnerait \u00e9galement. Comment cela est-ce possible ? Et bien range() est une fonction qui a \u00e9t\u00e9 sp\u00e9cialement con\u00e7ue pour cela, c'est-\u00e0-dire que l'on peut it\u00e9rer directement dessus. Pour Python , il s'agit d'un nouveau type, par exemple dans l'instruction x = range(3) la variable x est de type range (tout comme on avait les types int, float, str ou list ) \u00e0 utiliser sp\u00e9cialement avec les boucles. L'instruction list(range(4)) se contente de transformer un objet de type range en un objet de type list . Si vous vous souvenez bien, il s'agit d'une fonction de casting , qui convertit un type en un autre (voir chapitre 2 Variables ). Il n'y aucun int\u00e9r\u00eat \u00e0 utiliser dans une boucle la construction for i in list(range(4)): . C'est m\u00eame contre-productif. En effet, range() se contente de stocker l'entier actuel, le pas pour passer \u00e0 l'entier suivant, et le dernier entier \u00e0 parcourir, ce qui revient \u00e0 stocker seulement 3 nombres entiers et ce quelle que soit la longueur de la s\u00e9quence, m\u00eame avec un range(1000000) . Si on utilisait list(range(1000000)) , Python construirait d'abord une liste de 1 million d'\u00e9l\u00e9ments dans la m\u00e9moire puis it\u00e9rerait dessus, d'o\u00f9 une \u00e9norme perte de temps ! Nommage de la variable d'it\u00e9ration Dans l'exemple pr\u00e9c\u00e9dent, nous avons choisi le nom i pour la variable d'it\u00e9ration. Ceci est une habitude en informatique et indique en g\u00e9n\u00e9ral qu'il s'agit d'un entier (le nom i vient sans doute du mot indice ou index en anglais). Nous vous conseillons de suivre cette convention afin d'\u00e9viter les confusions, si vous it\u00e9rez sur les indices vous pouvez appeler la variable d'it\u00e9ration i (par exemple dans for i in range(4): ). Si, par contre, vous it\u00e9rez sur une liste comportant des cha\u00eenes de caract\u00e8res, mettez un nom explicite pour la variable d'it\u00e9ration. Par exemple : for prenom in [\"Joe\", \"Bill\", \"John\"]: It\u00e9ration sur les indices Revenons \u00e0 notre liste animaux . Nous allons maintenant parcourir cette liste, mais cette fois par une it\u00e9ration sur ses indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( 4 ): ... print ( animaux [ i ]) ... girafe tigre singe souris La variable i prendra les valeurs successives 0, 1, 2 et 3 et on acc\u00e8dera \u00e0 chaque \u00e9l\u00e9ment de la liste animaux par son indice (i.e. animaux[i] ). Notez \u00e0 nouveau le nom i de la variable d'it\u00e9ration car on it\u00e8re sur les indices . Quand utiliser l'une ou l'autre des 2 m\u00e9thodes ? La plus efficace est celle qui r\u00e9alise les it\u00e9rations directement sur les \u00e9l\u00e9ments : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris Toutefois, il se peut qu'au cours d'une boucle vous ayez besoin des indices, auquel cas vous devrez it\u00e9rer sur les indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( len ( animaux )): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris Python poss\u00e8de toutefois la fonction enumerate() qui vous permet d'it\u00e9rer sur les indices et les \u00e9l\u00e9ments eux-m\u00eames. 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i , animal in enumerate ( animaux ): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris Comparaisons Avant de passer \u00e0 une autre sorte de boucles (les boucles while ), nous abordons tout de suite les comparaisons . Celles-ci seront reprises dans le chapitre 6 sur les Tests . Python est capable d'effectuer toute une s\u00e9rie de comparaisons entre le contenu de deux variables, telles que : Syntaxe Python Signification == \u00e9gal \u00e0 != diff\u00e9rent de > sup\u00e9rieur \u00e0 >= sup\u00e9rieur ou \u00e9gal \u00e0 < inf\u00e9rieur \u00e0 <= inf\u00e9rieur ou \u00e9gal \u00e0 Observez les exemples suivants avec des nombres entiers. 1 2 3 4 5 6 7 >>> x = 5 >>> x == 5 True >>> x > 10 False >>> x < 10 True Python renvoie la valeur True si la comparaison est vraie et False si elle est fausse. True et False sont des bool\u00e9ens (un nouveau type de variable). Faites bien attention \u00e0 ne pas confondre l' op\u00e9rateur d'affectation = qui affecte une valeur \u00e0 une variable et l' op\u00e9rateur de comparaison == qui compare les valeurs de deux variables. Vous pouvez \u00e9galement effectuer des comparaisons sur des cha\u00eenes de caract\u00e8res. 1 2 3 4 5 6 7 >>> animal = \"tigre\" >>> animal == \"tig\" False >>> animal != \"tig\" True >>> animal == \"tigre\" True Dans le cas des cha\u00eenes de caract\u00e8res, a priori seuls les tests == et != ont un sens. En fait, on peut aussi utiliser les op\u00e9rateurs < , > , <= et >= . Dans ce cas, l'ordre alphab\u00e9tique est pris en compte, par exemple : 1 2 >>> \"a\" < \"b\" True \"a\" est inf\u00e9rieur \u00e0 \"b\" car le caract\u00e8re a est situ\u00e9 avant le caract\u00e8re b dans l'ordre alphab\u00e9tique. En fait, c'est l'ordre ASCII des caract\u00e8res qui est pris en compte (\u00e0 chaque caract\u00e8re correspond un code num\u00e9rique), on peut donc aussi comparer des caract\u00e8res sp\u00e9ciaux (comme # ou ~ ) entre eux. Enfin, on peut comparer des cha\u00eenes de caract\u00e8res de plusieurs caract\u00e8res : 1 2 3 4 >>> \"ali\" < \"alo\" True >>> \"abb\" < \"ada\" True Dans ce cas, Python compare les deux cha\u00eenes de caract\u00e8res, caract\u00e8re par caract\u00e8re, de la gauche vers la droite (le premier caract\u00e8re avec le premier, le deuxi\u00e8me avec le deuxi\u00e8me, etc). D\u00e8s qu'un caract\u00e8re est diff\u00e9rent entre l'une et l'autre des deux cha\u00eenes, il consid\u00e8re que la cha\u00eene la plus petite est celle qui pr\u00e9sente le caract\u00e8re ayant le plus petit code ASCII (les caract\u00e8res suivants de la cha\u00eene de caract\u00e8res sont ignor\u00e9s dans la comparaison), comme dans l'exemple \"abb\" < \"ada\" ci-dessus. Boucles while Une autre alternative \u00e0 l'instruction for couramment utilis\u00e9e en informatique est la boucle while . Le principe est simple. Une s\u00e9rie d'instructions est ex\u00e9cut\u00e9e tant qu'une condition est vraie. Par exemple : 1 2 3 4 5 6 7 8 9 >>> i = 1 >>> while i <= 4 : ... print ( i ) ... i = i + 1 ... 1 2 3 4 Remarquez qu'il est encore une fois n\u00e9cessaire d'indenter le bloc d'instructions correspondant au corps de la boucle (ici, les instructions lignes 3 et 4). Une boucle while n\u00e9cessite g\u00e9n\u00e9ralement trois \u00e9l\u00e9ments pour fonctionner correctement : Initialisation de la variable d'it\u00e9ration avant la boucle (ligne 1). Test de la variable d'it\u00e9ration associ\u00e9e \u00e0 l'instruction while (ligne 2). Mise \u00e0 jour de la variable d'it\u00e9ration dans le corps de la boucle (ligne 4). Faites bien attention aux tests et \u00e0 l'incr\u00e9mentation que vous utilisez car une erreur m\u00e8ne souvent \u00e0 des \u00ab boucles infinies \u00bb qui ne s'arr\u00eatent jamais. Vous pouvez n\u00e9anmoins toujours stopper l'ex\u00e9cution d'un script Python \u00e0 l'aide de la combinaison de touches Ctrl-C (c'est-\u00e0-dire en pressant simultan\u00e9ment les touches Ctrl et C ). Par exemple : 1 2 3 i = 0 while i < 10 : print ( \"Le python c'est cool !\" ) Ici, nous avons omis de mettre \u00e0 jour la variable i dans le corps de la boucle. Par cons\u00e9quent, la boucle ne s'arr\u00eatera jamais (sauf en pressant Ctrl-C ) puisque la condition i < 10 sera toujours vraie. La boucle while combin\u00e9e \u00e0 la fonction input() peut s'av\u00e9rer commode lorsqu'on souhaite demander \u00e0 l'utilisateur une valeur num\u00e9rique. Par exemple : 1 2 3 4 5 6 7 8 9 10 >>> i = 0 >>> while i < 10 : ... reponse = input ( \"Entrez un entier sup\u00e9rieur \u00e0 10 : \" ) ... i = int ( reponse ) ... Entrez un entier sup\u00e9rieur \u00e0 10 : 4 Entrez un entier sup\u00e9rieur \u00e0 10 : - 3 Entrez un entier sup\u00e9rieur \u00e0 10 : 15 >>> i 15 La fonction input() prend en argument un message (sous la forme d'une cha\u00eene de caract\u00e8res), demande \u00e0 l'utilisateur d'entrer une valeur et renvoie celle-ci sous forme d'une cha\u00eene de caract\u00e8res. Il faut ensuite convertir cette derni\u00e8re en entier (avec la fonction int() ).","title":"Boucles et comparaisons"},{"location":"Python/boucles/#boucles-et-comparaisons","text":"","title":"Boucles et comparaisons"},{"location":"Python/boucles/#boucles-for","text":"","title":"Boucles for"},{"location":"Python/boucles/#principe","text":"En programmation, on est souvent amen\u00e9 \u00e0 r\u00e9p\u00e9ter plusieurs fois une instruction. Incontournables \u00e0 tout langage de programmation, les boucles vont nous aider \u00e0 r\u00e9aliser cette t\u00e2che de mani\u00e8re compacte et efficace. Imaginez par exemple que vous souhaitiez afficher les \u00e9l\u00e9ments d'une liste les uns apr\u00e8s les autres. Dans l'\u00e9tat actuel de vos connaissances, il faudrait taper quelque chose du style : 1 2 3 4 5 animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] print ( animaux [ 0 ]) print ( animaux [ 1 ]) print ( animaux [ 2 ]) print ( animaux [ 3 ]) Si votre liste ne contient que 4 \u00e9l\u00e9ments, ceci est encore faisable mais imaginez qu'elle en contienne 100 voire 1000 ! Pour rem\u00e9dier \u00e0 cela, il faut utiliser les boucles. Regardez l'exemple suivant : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris La variable animal est appel\u00e9e variable d'it\u00e9ration , elle prend successivement les diff\u00e9rentes valeurs de la liste animaux \u00e0 chaque it\u00e9ration de la boucle. On verra un peu plus loin dans ce chapitre que l'on peut choisir le nom que l'on veut pour cette variable. Celle-ci est cr\u00e9\u00e9e par Python la premi\u00e8re fois que la ligne contenant le for est ex\u00e9cut\u00e9e (si elle existait d\u00e9j\u00e0 son contenu serait \u00e9cras\u00e9). Une fois la boucle termin\u00e9e, cette variable d'it\u00e9ration animal ne sera pas d\u00e9truite et contiendra ainsi la derni\u00e8re valeur de la liste animaux (ici la cha\u00eene de caract\u00e8res souris ). Notez bien les types des variables utilis\u00e9es ici : animaux est une liste sur laquelle on it\u00e8re, et animal est une cha\u00eene de caract\u00e8res car chaque \u00e9l\u00e9ment de la liste est une cha\u00eene de caract\u00e8res. Nous verrons plus loin que la variable d'it\u00e9ration peut \u00eatre de n'importe quel type selon la liste parcourue. En Python , une boucle it\u00e8re toujours sur un objet dit s\u00e9quentiel (c'est-\u00e0-dire un objet constitu\u00e9 d'autres objets) tel qu'une liste. Nous verrons aussi plus tard d'autres objets s\u00e9quentiels sur lesquels on peut it\u00e9rer dans une boucle. D'ores et d\u00e9j\u00e0, pr\u00eatez attention au caract\u00e8re deux-points \u00ab : \u00bb \u00e0 la fin de la ligne d\u00e9butant par for . Cela signifie que la boucle for attend un bloc d'instructions , en l\u2019occurrence toutes les instructions que Python r\u00e9p\u00e9tera \u00e0 chaque it\u00e9ration de la boucle. On appelle ce bloc d'instructions le corps de la boucle . Comment indique-t-on \u00e0 Python o\u00f9 ce bloc commence et se termine ? Cela est signal\u00e9 uniquement par l' indentation , c'est-\u00e0-dire le d\u00e9calage vers la droite de la (ou des) ligne(s) du bloc d'instructions. Dans l'exemple suivant, le corps de la boucle contient deux instructions : print(animal) et print(animal*2) car elles sont indent\u00e9es par rapport \u00e0 la ligne d\u00e9butant par for : 1 2 3 4 for animal in animaux : print ( animal ) print ( animal * 2 ) print ( \"C'est fini\" ) La ligne 4 print(\"C'est fini\") ne fait pas partie du corps de la boucle car elle est au m\u00eame niveau que le for (c'est-\u00e0-dire non indent\u00e9e par rapport au for ). Notez \u00e9galement que chaque instruction du corps de la boucle doit \u00eatre indent\u00e9e de la m\u00eame mani\u00e8re (ici 4 espaces). Remarque Outre une meilleure lisibilit\u00e9, les deux-points et l' indentation sont formellement requis en Python. M\u00eame si on peut indenter comme on veut (plusieurs espaces ou plusieurs tabulations, mais pas une combinaison des deux), les d\u00e9veloppeurs recommandent l'utilisation de quatre espaces. Vous pouvez consulter \u00e0 ce sujet le chapitre 15 Bonnes pratiques de programmation en Python . Faites en sorte de configurer votre \u00e9diteur de texte favori de fa\u00e7on \u00e0 \u00e9crire quatre espaces lorsque vous tapez sur la touche Tab (tabulation). Si on oublie l'indentation, Python renvoie un message d'erreur : 1 2 3 4 5 6 >>> for animal in animaux : ... print ( animal ) File \"<stdin>\" , line 2 print ( animal ) ^ IndentationError : expected an indented block Dans les exemples ci-dessus, nous avons ex\u00e9cut\u00e9 une boucle en it\u00e9rant directement sur une liste. Une tranche d'une liste \u00e9tant elle m\u00eame une liste, on peut \u00e9galement it\u00e9rer dessus : 1 2 3 4 5 6 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux [ 1 : 3 ]: ... print ( animal ) ... tigre singe On a vu que les boucles for pouvaient utiliser une liste contenant des cha\u00eenes de caract\u00e8res, mais elles peuvent tout aussi bien utiliser des listes contenant des entiers (ou n'importe quel type de variable). 1 2 3 4 5 6 >>> for i in [ 1 , 2 , 3 ]: ... print ( i ) ... 1 2 3","title":"Principe"},{"location":"Python/boucles/#fonction-range","text":"Python poss\u00e8de la fonction range() que nous avons rencontr\u00e9e pr\u00e9c\u00e9demment dans le chapitre 4 sur les Listes et qui est aussi bien commode pour faire une boucle sur une liste d'entiers de mani\u00e8re automatique : 1 2 3 4 5 6 7 >>> for i in range ( 4 ): ... print ( i ) ... 0 1 2 3 Dans cet exemple, nous pouvons faire plusieurs remarques importantes : Contrairement \u00e0 la cr\u00e9ation de liste avec list(range(4)) , la fonction range() peut \u00eatre utilis\u00e9e telle quelle dans une boucle. Il n'est pas n\u00e9cessaire de taper for i in list(range(4)): m\u00eame si cela fonctionnerait \u00e9galement. Comment cela est-ce possible ? Et bien range() est une fonction qui a \u00e9t\u00e9 sp\u00e9cialement con\u00e7ue pour cela, c'est-\u00e0-dire que l'on peut it\u00e9rer directement dessus. Pour Python , il s'agit d'un nouveau type, par exemple dans l'instruction x = range(3) la variable x est de type range (tout comme on avait les types int, float, str ou list ) \u00e0 utiliser sp\u00e9cialement avec les boucles. L'instruction list(range(4)) se contente de transformer un objet de type range en un objet de type list . Si vous vous souvenez bien, il s'agit d'une fonction de casting , qui convertit un type en un autre (voir chapitre 2 Variables ). Il n'y aucun int\u00e9r\u00eat \u00e0 utiliser dans une boucle la construction for i in list(range(4)): . C'est m\u00eame contre-productif. En effet, range() se contente de stocker l'entier actuel, le pas pour passer \u00e0 l'entier suivant, et le dernier entier \u00e0 parcourir, ce qui revient \u00e0 stocker seulement 3 nombres entiers et ce quelle que soit la longueur de la s\u00e9quence, m\u00eame avec un range(1000000) . Si on utilisait list(range(1000000)) , Python construirait d'abord une liste de 1 million d'\u00e9l\u00e9ments dans la m\u00e9moire puis it\u00e9rerait dessus, d'o\u00f9 une \u00e9norme perte de temps !","title":"Fonction range()"},{"location":"Python/boucles/#nommage-de-la-variable-diteration","text":"Dans l'exemple pr\u00e9c\u00e9dent, nous avons choisi le nom i pour la variable d'it\u00e9ration. Ceci est une habitude en informatique et indique en g\u00e9n\u00e9ral qu'il s'agit d'un entier (le nom i vient sans doute du mot indice ou index en anglais). Nous vous conseillons de suivre cette convention afin d'\u00e9viter les confusions, si vous it\u00e9rez sur les indices vous pouvez appeler la variable d'it\u00e9ration i (par exemple dans for i in range(4): ). Si, par contre, vous it\u00e9rez sur une liste comportant des cha\u00eenes de caract\u00e8res, mettez un nom explicite pour la variable d'it\u00e9ration. Par exemple : for prenom in [\"Joe\", \"Bill\", \"John\"]:","title":"Nommage de la variable d'it\u00e9ration"},{"location":"Python/boucles/#iteration-sur-les-indices","text":"Revenons \u00e0 notre liste animaux . Nous allons maintenant parcourir cette liste, mais cette fois par une it\u00e9ration sur ses indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( 4 ): ... print ( animaux [ i ]) ... girafe tigre singe souris La variable i prendra les valeurs successives 0, 1, 2 et 3 et on acc\u00e8dera \u00e0 chaque \u00e9l\u00e9ment de la liste animaux par son indice (i.e. animaux[i] ). Notez \u00e0 nouveau le nom i de la variable d'it\u00e9ration car on it\u00e8re sur les indices . Quand utiliser l'une ou l'autre des 2 m\u00e9thodes ? La plus efficace est celle qui r\u00e9alise les it\u00e9rations directement sur les \u00e9l\u00e9ments : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for animal in animaux : ... print ( animal ) ... girafe tigre singe souris Toutefois, il se peut qu'au cours d'une boucle vous ayez besoin des indices, auquel cas vous devrez it\u00e9rer sur les indices : 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i in range ( len ( animaux )): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris Python poss\u00e8de toutefois la fonction enumerate() qui vous permet d'it\u00e9rer sur les indices et les \u00e9l\u00e9ments eux-m\u00eames. 1 2 3 4 5 6 7 8 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> for i , animal in enumerate ( animaux ): ... print ( f \"L'animal { i } est un(e) { animaux [ i ] } \" ) ... L 'animal 0 est un(e) girafe L 'animal 1 est un(e) tigre L 'animal 2 est un(e) singe L 'animal 3 est un(e) souris","title":"It\u00e9ration sur les indices"},{"location":"Python/boucles/#comparaisons","text":"Avant de passer \u00e0 une autre sorte de boucles (les boucles while ), nous abordons tout de suite les comparaisons . Celles-ci seront reprises dans le chapitre 6 sur les Tests . Python est capable d'effectuer toute une s\u00e9rie de comparaisons entre le contenu de deux variables, telles que : Syntaxe Python Signification == \u00e9gal \u00e0 != diff\u00e9rent de > sup\u00e9rieur \u00e0 >= sup\u00e9rieur ou \u00e9gal \u00e0 < inf\u00e9rieur \u00e0 <= inf\u00e9rieur ou \u00e9gal \u00e0 Observez les exemples suivants avec des nombres entiers. 1 2 3 4 5 6 7 >>> x = 5 >>> x == 5 True >>> x > 10 False >>> x < 10 True Python renvoie la valeur True si la comparaison est vraie et False si elle est fausse. True et False sont des bool\u00e9ens (un nouveau type de variable). Faites bien attention \u00e0 ne pas confondre l' op\u00e9rateur d'affectation = qui affecte une valeur \u00e0 une variable et l' op\u00e9rateur de comparaison == qui compare les valeurs de deux variables. Vous pouvez \u00e9galement effectuer des comparaisons sur des cha\u00eenes de caract\u00e8res. 1 2 3 4 5 6 7 >>> animal = \"tigre\" >>> animal == \"tig\" False >>> animal != \"tig\" True >>> animal == \"tigre\" True Dans le cas des cha\u00eenes de caract\u00e8res, a priori seuls les tests == et != ont un sens. En fait, on peut aussi utiliser les op\u00e9rateurs < , > , <= et >= . Dans ce cas, l'ordre alphab\u00e9tique est pris en compte, par exemple : 1 2 >>> \"a\" < \"b\" True \"a\" est inf\u00e9rieur \u00e0 \"b\" car le caract\u00e8re a est situ\u00e9 avant le caract\u00e8re b dans l'ordre alphab\u00e9tique. En fait, c'est l'ordre ASCII des caract\u00e8res qui est pris en compte (\u00e0 chaque caract\u00e8re correspond un code num\u00e9rique), on peut donc aussi comparer des caract\u00e8res sp\u00e9ciaux (comme # ou ~ ) entre eux. Enfin, on peut comparer des cha\u00eenes de caract\u00e8res de plusieurs caract\u00e8res : 1 2 3 4 >>> \"ali\" < \"alo\" True >>> \"abb\" < \"ada\" True Dans ce cas, Python compare les deux cha\u00eenes de caract\u00e8res, caract\u00e8re par caract\u00e8re, de la gauche vers la droite (le premier caract\u00e8re avec le premier, le deuxi\u00e8me avec le deuxi\u00e8me, etc). D\u00e8s qu'un caract\u00e8re est diff\u00e9rent entre l'une et l'autre des deux cha\u00eenes, il consid\u00e8re que la cha\u00eene la plus petite est celle qui pr\u00e9sente le caract\u00e8re ayant le plus petit code ASCII (les caract\u00e8res suivants de la cha\u00eene de caract\u00e8res sont ignor\u00e9s dans la comparaison), comme dans l'exemple \"abb\" < \"ada\" ci-dessus.","title":"Comparaisons"},{"location":"Python/boucles/#boucles-while","text":"Une autre alternative \u00e0 l'instruction for couramment utilis\u00e9e en informatique est la boucle while . Le principe est simple. Une s\u00e9rie d'instructions est ex\u00e9cut\u00e9e tant qu'une condition est vraie. Par exemple : 1 2 3 4 5 6 7 8 9 >>> i = 1 >>> while i <= 4 : ... print ( i ) ... i = i + 1 ... 1 2 3 4 Remarquez qu'il est encore une fois n\u00e9cessaire d'indenter le bloc d'instructions correspondant au corps de la boucle (ici, les instructions lignes 3 et 4). Une boucle while n\u00e9cessite g\u00e9n\u00e9ralement trois \u00e9l\u00e9ments pour fonctionner correctement : Initialisation de la variable d'it\u00e9ration avant la boucle (ligne 1). Test de la variable d'it\u00e9ration associ\u00e9e \u00e0 l'instruction while (ligne 2). Mise \u00e0 jour de la variable d'it\u00e9ration dans le corps de la boucle (ligne 4). Faites bien attention aux tests et \u00e0 l'incr\u00e9mentation que vous utilisez car une erreur m\u00e8ne souvent \u00e0 des \u00ab boucles infinies \u00bb qui ne s'arr\u00eatent jamais. Vous pouvez n\u00e9anmoins toujours stopper l'ex\u00e9cution d'un script Python \u00e0 l'aide de la combinaison de touches Ctrl-C (c'est-\u00e0-dire en pressant simultan\u00e9ment les touches Ctrl et C ). Par exemple : 1 2 3 i = 0 while i < 10 : print ( \"Le python c'est cool !\" ) Ici, nous avons omis de mettre \u00e0 jour la variable i dans le corps de la boucle. Par cons\u00e9quent, la boucle ne s'arr\u00eatera jamais (sauf en pressant Ctrl-C ) puisque la condition i < 10 sera toujours vraie. La boucle while combin\u00e9e \u00e0 la fonction input() peut s'av\u00e9rer commode lorsqu'on souhaite demander \u00e0 l'utilisateur une valeur num\u00e9rique. Par exemple : 1 2 3 4 5 6 7 8 9 10 >>> i = 0 >>> while i < 10 : ... reponse = input ( \"Entrez un entier sup\u00e9rieur \u00e0 10 : \" ) ... i = int ( reponse ) ... Entrez un entier sup\u00e9rieur \u00e0 10 : 4 Entrez un entier sup\u00e9rieur \u00e0 10 : - 3 Entrez un entier sup\u00e9rieur \u00e0 10 : 15 >>> i 15 La fonction input() prend en argument un message (sous la forme d'une cha\u00eene de caract\u00e8res), demande \u00e0 l'utilisateur d'entrer une valeur et renvoie celle-ci sous forme d'une cha\u00eene de caract\u00e8res. Il faut ensuite convertir cette derni\u00e8re en entier (avec la fonction int() ).","title":"Boucles while"},{"location":"Python/fonction/","text":"Fonctions Principe et g\u00e9n\u00e9ralit\u00e9s En programmation, les fonctions sont tr\u00e8s utiles pour r\u00e9aliser plusieurs fois la m\u00eame op\u00e9ration au sein d'un programme. Elles rendent \u00e9galement le code plus lisible et plus clair en le fractionnant en blocs logiques. Vous connaissez d\u00e9j\u00e0 certaines fonctions Python . Par exemple math.cos(angle) du module math renvoie le cosinus de la variable angle exprim\u00e9 en radian. Vous connaissez aussi des fonctions internes \u00e0 Python comme range() ou len() . Pour l'instant, une fonction est \u00e0 vos yeux une sorte de \u00ab bo\u00eete noire \u00bb (voir figure 1) : \u00c0 laquelle vous passez aucune, une ou plusieurs variable(s) entre parenth\u00e8ses. Ces variables sont appel\u00e9es arguments . Il peut s'agir de n'importe quel type d'objet Python. Qui effectue une action. Et qui renvoie un objet Python ou rien du tout. Fonctionnement sch\u00e9matique d'une fonction. Par exemple, si vous appelez la fonction len() de la mani\u00e8re suivante : 1 2 >>> len ([ 0 , 1 , 2 ]) 3 voici ce qui se passe : vous appelez len() en lui passant une liste en argument (ici la liste [0, 1, 2] ) ; la fonction calcule la longueur de cette liste ; elle vous renvoie un entier \u00e9gal \u00e0 cette longueur. Autre exemple, si vous appelez la m\u00e9thode ma_liste.append() (n'oubliez pas, une m\u00e9thode est une fonction qui agit sur l'objet auquel elle est attach\u00e9e par un point) : 1 >>> ma_liste . append ( 5 ) Vous passez l'entier 5 en argument ; la m\u00e9thode append() ajoute l'entier 5 \u00e0 l'objet ma_liste ; et elle ne renvoie rien. Aux yeux du programmeur au contraire, une fonction est une portion de code effectuant une suite d'instructions bien particuli\u00e8re. Mais avant de vous pr\u00e9senter la syntaxe et la mani\u00e8re de construire une fonction, revenons une derni\u00e8re fois sur cette notion de \u00ab bo\u00eete noire \u00bb : Une fonction effectue une t\u00e2che. Pour cela, elle re\u00e7oit \u00e9ventuellement des arguments et renvoie \u00e9ventuellement quelque chose. L'algorithme utilis\u00e9 au sein de la fonction n'int\u00e9resse pas directement l'utilisateur. Par exemple, il est inutile de savoir comment la fonction math.cos() calcule un cosinus. On a juste besoin de savoir qu'il faut lui passer en argument un angle en radian et qu'elle renvoie le cosinus de cet angle. Ce qui se passe \u00e0 l'int\u00e9rieur de la fonction ne regarde que le programmeur. Chaque fonction effectue en g\u00e9n\u00e9ral une t\u00e2che unique et pr\u00e9cise. Si cela se complique, il est plus judicieux d'\u00e9crire plusieurs fonctions (qui peuvent \u00e9ventuellement s'appeler les unes les autres). Cette modularit\u00e9 am\u00e9liore la qualit\u00e9 g\u00e9n\u00e9rale et la lisibilit\u00e9 du code. Vous verrez qu'en Python, les fonctions pr\u00e9sentent une grande flexibilit\u00e9. Pour finir sur les g\u00e9n\u00e9ralit\u00e9s, nous avons utilis\u00e9 dans la Figure 1 le terme programme principal ( main en anglais) pour d\u00e9signer l'endroit depuis lequel on appelle une fonction (on verra plus tard que l'on peut en fait appeler une fonction de n'importe o\u00f9). Le programme principal d\u00e9signe le code qui est ex\u00e9cut\u00e9 lorsqu'on lance le script Python , c'est-\u00e0-dire toute la suite d'instructions en dehors des fonctions. En g\u00e9n\u00e9ral, dans un script Python , on \u00e9crit d'abord les fonctions puis le programme principal. Nous aurons l'occasion de revenir sur cette notion de programme principal plus tard dans ce chapitre ainsi que dans le chapitre 12 Plus sur les fonctions . D\u00e9finition Pour d\u00e9finir une fonction, Python utilise le mot-cl\u00e9 def . Si on souhaite que la fonction renvoie quelque chose, il faut utiliser le mot-cl\u00e9 return . Par exemple : 1 2 3 4 5 >>> def carre ( x ): ... return x ** 2 ... >>> print ( carre ( 2 )) 4 Notez que la syntaxe de def utilise les deux-points comme les boucles for et while ainsi que les tests if , un bloc d\u2019instructions est donc attendu. De m\u00eame que pour les boucles et les tests, l' indentation de ce bloc d'instructions (qu'on appelle le corps de la fonction) est obligatoire . Dans l'exemple pr\u00e9c\u00e9dent, nous avons pass\u00e9 un argument \u00e0 la fonction carre() qui nous a renvoy\u00e9 (ou retourn\u00e9) une valeur que nous avons imm\u00e9diatement affich\u00e9e \u00e0 l'\u00e9cran avec l'instruction print() . Que veut dire valeur renvoy\u00e9e ? Et bien cela signifie que cette derni\u00e8re est r\u00e9cup\u00e9rable dans une variable : 1 2 3 >>> res = carre ( 2 ) >>> print ( res ) 4 Ici, le r\u00e9sultat renvoy\u00e9 par la fonction est stock\u00e9 dans la variable res . Notez qu'une fonction ne prend pas forc\u00e9ment un argument et ne renvoie pas forc\u00e9ment une valeur, par exemple : 1 2 3 4 5 >>> def hello (): ... print ( \"bonjour\" ) ... >>> hello () bonjour Dans ce cas la fonction, hello() se contente d'afficher la cha\u00eene de caract\u00e8res \"bonjour\" \u00e0 l'\u00e9cran. Elle ne prend aucun argument et ne renvoie rien. Par cons\u00e9quent, cela n'a pas de sens de vouloir r\u00e9cup\u00e9rer dans une variable le r\u00e9sultat renvoy\u00e9 par une telle fonction. Si on essaie tout de m\u00eame, Python affecte la valeur None qui signifie rien en anglais: 1 2 3 4 >>> var = hello () bonjour >>> print ( var ) None Ceci n'est pas une faute car Python n'\u00e9met pas d'erreur, toutefois cela ne pr\u00e9sente, la plupart du temps, gu\u00e8re d'int\u00e9r\u00eat. Passage d'arguments Le nombre d'arguments que l'on peut passer \u00e0 une fonction est variable. Nous avons vu ci-dessus des fonctions auxquelles on passait 0 ou 1 argument. Dans les chapitres pr\u00e9c\u00e9dents, vous avez rencontr\u00e9 des fonctions internes \u00e0 Python qui prenaient au moins 2 arguments. Souvenez-vous par exemple de range(1, 10) ou encore range(1, 10, 2) . Le nombre d'argument est donc laiss\u00e9 libre \u00e0 l'initiative du programmeur qui d\u00e9veloppe une nouvelle fonction. Une particularit\u00e9 des fonctions en Python est que vous n'\u00eates pas oblig\u00e9 de pr\u00e9ciser le type des arguments que vous lui passez, d\u00e8s lors que les op\u00e9rations que vous effectuez avec ces arguments sont valides. Python est en effet connu comme \u00e9tant un langage au \u00ab typage dynamique \u00bb, c'est-\u00e0-dire qu'il reconna\u00eet pour vous le type des variables au moment de l'ex\u00e9cution. Par exemple : 1 2 3 4 5 6 7 8 9 10 11 >>> def fois(x, y): ... return x*y ... >>> fois(2, 3) 6 >>> fois(3.1415, 5.23) 16.430045000000003 >>> fois(\"to\", 2) 'toto' >>> fois([1,3], 2) [1, 3, 1, 3] L'op\u00e9rateur * reconna\u00eet plusieurs types (entiers, floats , cha\u00eenes de caract\u00e8res, listes). Notre fonction fois() est donc capable d'effectuer des t\u00e2ches diff\u00e9rentes ! M\u00eame si Python autorise cela, m\u00e9fiez-vous tout de m\u00eame de cette grande flexibilit\u00e9 qui pourrait conduire \u00e0 des surprises dans vos futurs programmes. En g\u00e9n\u00e9ral, il est plus judicieux que chaque argument ait un type pr\u00e9cis (entiers, floats , cha\u00eenes de caract\u00e8res, etc) et pas l'un ou l'autre. Renvoi de r\u00e9sultats Un \u00e9norme avantage en Python est que les fonctions sont capables de renvoyer plusieurs objets \u00e0 la fois, comme dans cette fraction de code : 1 2 3 4 5 >>> def carre_cube ( x ): ... return x ** 2 , x ** 3 ... >>> carre_cube ( 2 ) ( 4 , 8 ) En r\u00e9alit\u00e9 Python ne renvoie qu'un seul objet, mais celui-ci peut \u00eatre s\u00e9quentiel, c'est-\u00e0-dire contenir lui m\u00eame d'autres objets. Dans notre exemple Python renvoie un objet de type tuple , type que nous verrons dans le chapitre 13 Dictionnaires et tuples (grosso modo, il s'agit d'une sorte de liste avec des propri\u00e9t\u00e9s diff\u00e9rentes). Notre fonction pourrait tout autant renvoyer une liste : 1 2 3 4 5 >>> def carre_cube2 ( x ): ... return [ x ** 2 , x ** 3 ] ... >>> carre_cube2 ( 3 ) [ 9 , 27 ] Renvoyer un tuple ou une liste de deux \u00e9l\u00e9ments (ou plus) est tr\u00e8s pratique en conjonction avec l' affectation multiple , par exemple : 1 2 3 4 5 >>> z1 , z2 = carre_cube2 ( 3 ) >>> z1 9 >>> z2 27 Cela permet de r\u00e9cup\u00e9rer plusieurs valeurs renvoy\u00e9es par une fonction et de les affecter \u00e0 la vol\u00e9e \u00e0 des variables diff\u00e9rentes. Arguments positionnels et arguments par mot-cl\u00e9 Jusqu'\u00e0 maintenant, nous avons syst\u00e9matiquement pass\u00e9 le nombre d'arguments que la fonction attendait. Que se passe-t-il si une fonction attend deux arguments et que nous ne lui en passons qu'un seul ? 1 2 3 4 5 6 7 8 9 >>> def fois ( x , y ): ... return x * y ... >>> fois ( 2 , 3 ) 6 >>> fois ( 2 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : fois () missing 1 required positional argument : 'y' On constate que passer un seul argument \u00e0 une fonction qui en attend deux conduit \u00e0 une erreur. D\u00e9finition Lorsqu'on d\u00e9finit une fonction def fct(x, y): les arguments x et y sont appel\u00e9s arguments positionnels (en anglais positional arguments ). Il est strictement obligatoire de les pr\u00e9ciser lors de l'appel de la fonction. De plus, il est n\u00e9cessaire de respecter le m\u00eame ordre lors de l'appel que dans la d\u00e9finition de la fonction. Dans l'exemple ci-dessus, 2 correspondra \u00e0 x et 3 correspondra \u00e0 y . Finalement, tout d\u00e9pendra de leur position, d'o\u00f9 leur qualification de positionnel. Mais il est aussi possible de passer un ou plusieurs argument(s) de mani\u00e8re facultative et de leur attribuer une valeur par d\u00e9faut : 1 2 3 4 5 6 7 >>> def fct ( x = 1 ): ... return x ... >>> fct () 1 >>> fct ( 10 ) 10 D\u00e9finition Un argument d\u00e9fini avec une syntaxe def fct(arg=val): est appel\u00e9 argument par mot-cl\u00e9 (en anglais keyword argument). Le passage d'un tel argument lors de l'appel de la fonction est facultatif. Ce type d'argument ne doit pas \u00eatre confondu avec les arguments positionnels pr\u00e9sent\u00e9s ci-dessus, dont la syntaxe est def fct(arg):. Il est bien s\u00fbr possible de passer plusieurs arguments par mot-cl\u00e9 : def fct(x=0, y=0, z=0): ... return x, y, z ... fct() (0, 0, 0) fct(10) (10, 0, 0) fct(10, 8) (10, 8, 0) fct(10, 8, 3) (10, 8, 3) On observe que pour l'instant, les arguments par mot-cl\u00e9 sont pris dans l'ordre dans lesquels on les passe lors de l'appel. Comment pourrions-nous faire si on souhaitait pr\u00e9ciser l'argument par mot-cl\u00e9 z et garder les valeurs de x et y par d\u00e9faut ? Simplement en pr\u00e9cisant le nom de l'argument lors de l'appel : fct(z=10) (0, 0, 10) Python permet m\u00eame de rentrer les arguments par mot-cl\u00e9 dans un ordre arbitraire : fct(z=10, x=3, y=80) (3, 80, 10) fct(z=10, y=80) (0, 80, 10) Que se passe-t-il lorsque nous avons un m\u00e9lange d'arguments positionnels et par mot-cl\u00e9 ? Et bien les arguments positionnels doivent toujours \u00eatre plac\u00e9s avant les arguments par mot-cl\u00e9 : def fct(a, b, x=0, y=0, z=0): ... return a, b, x, y, z ... fct(1, 1) (1, 1, 0, 0, 0) fct(1, 1, z=5) (1, 1, 0, 0, 5) fct(1, 1, z=5, y=32) (1, 1, 0, 32, 5) On peut toujours passer les arguments par mot-cl\u00e9 dans un ordre arbitraire \u00e0 partir du moment o\u00f9 on pr\u00e9cise leur nom. Par contre, si les deux arguments positionnels a et b ne sont pas pass\u00e9s \u00e0 la fonction, Python renvoie une erreur. fct(z=0) Traceback (most recent call last): File \" \", line 1, in TypeError: fct() missing 2 required positional arguments: 'a' and 'b' Conseils Pr\u00e9ciser le nom des arguments par mot-cl\u00e9 lors de l'appel d'une fonction est une pratique que nous vous recommandons. Cela les distingue clairement des arguments positionnels. L'utilisation d'arguments par mot-cl\u00e9 est habituelle en Python. Elle permet de modifier le comportement par d\u00e9faut de nombreuses fonctions. Par exemple, si on souhaite que la fonction print() n'affiche pas un retour \u00e0 la ligne, on peut utiliser l'argument end : print(\"Message \", end=\"\") Message >>> Nous verrons, dans le chapitre 20 Fen\u00eatres graphiques et Tkinter, que l'utilisation d'arguments par mot-cl\u00e9 est syst\u00e9matique lorsqu'on cr\u00e9e un objet graphique (une fen\u00eatre, un bouton, etc.). 9.6 Variables locales et variables globales Lorsqu'on manipule des fonctions, il est essentiel de bien comprendre comment se comportent les variables. Une variable est dite locale lorsqu'elle est cr\u00e9\u00e9e dans une fonction. Elle n'existera et ne sera visible que lors de l'ex\u00e9cution de ladite fonction. Une variable est dite globale lorsqu'elle est cr\u00e9\u00e9e dans le programme principal. Elle sera visible partout dans le programme. Ceci ne vous para\u00eet pas clair ? Nous allons prendre un exemple simple qui vous aidera \u00e0 mieux saisir ces concepts. Observez le code suivant : d\u00e9finition d'une fonction carre() def carre(x): y = x**2 return y programme principal z = 5 resultat = carre(z) print(resultat) Pour la suite des explications, nous allons utiliser l'excellent site Python Tutor qui permet de visualiser l'\u00e9tat des variables au fur et \u00e0 mesure de l'ex\u00e9cution d'un code Python. Avant de poursuivre, nous vous conseillons de prendre 5 minutes pour tester ce site. Regardons maintenant ce qui se passe dans le code ci-dessus, \u00e9tape par \u00e9tape : 1 \u00c9tape 1 : Python est pr\u00eat \u00e0 lire la premi\u00e8re ligne de code. \u00c9tape 1. Figure 2. \u00c9tape 1. 1 \u00c9tape 2 : Python met en m\u00e9moire la fonction carre(). Notez qu'il ne l'ex\u00e9cute pas ! La fonction est mise dans un espace de la m\u00e9moire nomm\u00e9 Global frame, il s'agit de l'espace du programme principal. Dans cet espace, seront stock\u00e9es toutes les variables globales cr\u00e9\u00e9es dans le programme. Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter le programme principal. \u00c9tape 2. Figure 3. \u00c9tape 2. 1 \u00c9tape 3 : Python lit et met en m\u00e9moire la variable z. Celle-ci \u00e9tant cr\u00e9\u00e9e dans le programme principal, il s'agira d'une variable globale. Ainsi, elle sera \u00e9galement stock\u00e9e dans le Global frame. \u00c9tape 3. Figure 4. \u00c9tape 3. 1 \u00c9tape 4 : La fonction carre() est appel\u00e9e et on lui passe en argument l'entier z. La fonction s'ex\u00e9cute et un nouveau cadre est cr\u00e9\u00e9 dans lequel Python Tutor va indiquer toutes les variables locales \u00e0 la fonction. Notez bien que la variable pass\u00e9e en argument, qui s'appelle x dans la fonction, est cr\u00e9\u00e9e en tant que variable locale. On remarquera aussi que les variables globales situ\u00e9es dans le Global frame sont toujours l\u00e0. \u00c9tape 4. Figure 5. \u00c9tape 4. 1 \u00c9tape 5 : Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter chaque ligne de code de la fonction. \u00c9tape 5. Figure 6. \u00c9tape 5. 1 \u00c9tape 6 : La variable y est cr\u00e9\u00e9e dans la fonction. Celle-ci est donc stock\u00e9e en tant que variable locale \u00e0 la fonction. \u00c9tape 6. Figure 7. \u00c9tape 6. 1 \u00c9tape 7 : Python s'appr\u00eate \u00e0 renvoyer la variable locale y au programme principal. Python Tutor nous indique le contenu de la valeur renvoy\u00e9e. \u00c9tape 7. Figure 8. \u00c9tape 7. 1 \u00c9tape 8 : Python quitte la fonction et la valeur renvoy\u00e9e par celle-ci est affect\u00e9e \u00e0 la variable globale resultat. Notez bien que lorsque Python quitte la fonction, l'espace des variables allou\u00e9 \u00e0 la fonction est d\u00e9truit. Ainsi, toutes les variables cr\u00e9\u00e9es dans la fonction n'existent plus. On comprend pourquoi elles portent le nom de locales puisqu'elles n'existent que lorsque la fonction est ex\u00e9cut\u00e9e. \u00c9tape 8. Figure 9. \u00c9tape 8. 1 \u00c9tape 9 : Python affiche le contenu de la variable resultat et l'ex\u00e9cution est termin\u00e9e. \u00c9tape 9. Figure 10. \u00c9tape 9. Nous esp\u00e9rons que cet exemple guid\u00e9 facilitera la compr\u00e9hension des concepts de variables locales et globales. Cela viendra aussi avec la pratique. Nous irons un peu plus loin sur les fonctions dans le chapitre 12. D'ici l\u00e0, essayez de vous entra\u00eener au maximum avec les fonctions. C'est un concept ardu, mais il est imp\u00e9ratif de le ma\u00eetriser. Enfin, comme vous avez pu le constater, Python Tutor nous a grandement aid\u00e9 \u00e0 comprendre ce qui se passait. N'h\u00e9sitez pas \u00e0 l'utiliser sur des exemples ponctuels, ce site vous aidera \u00e0 visualiser ce qui se passe lorsqu'un code ne fait pas ce que vous attendez. 9.7 Principe DRY L'acronyme DRY signifie Don't Repeat Yourself. Les fonctions permettent de satisfaire ce principe en \u00e9vitant la duplication de code. En effet, plus un code est dupliqu\u00e9 plusieurs fois dans un programme, plus il sera source d'erreurs, notamment lorsqu'il faudra le faire \u00e9voluer. Consid\u00e9rons par exemple le code suivant qui convertit plusieurs temp\u00e9ratures des degr\u00e9s Fahrenheit en degr\u00e9s Celsius : temp_in_fahrenheit = 60 (temp_in_fahrenheit - 32) * (5/8) 17.5 temp_in_fahrenheit = 80 (temp_in_fahrenheit - 32) * (5/8) 30.0 temp_in_fahrenheit = 100 (temp_in_fahrenheit - 32) * (5/8) 42.5 Malheureusement il y a une erreur dans la formule de conversion. En effet la formule exacte est : temp_celsius=(temp_fahrenheit\u221232)\u00d759 Il faut alors reprendre les lignes 2, 5 et 8 pr\u00e9c\u00e9dentes et les corriger. Cela n'est pas efficace, surtout si le m\u00eame code est utilis\u00e9 \u00e0 diff\u00e9rents endroits dans le programme. En \u00e9crivant qu'une seule fois la formule de conversion dans une fonction, on applique le principe DRY : def convert_fahrenheit_to_celsius(temperature): ... return (temperature - 32) * (5/9) ... temp_in_fahrenheit = 60 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 15.555555555555557 temp_in_fahrenheit = 80 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 26.666666666666668 temp_in_fahrenheit = 100 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 37.77777777777778 Et s'il y a une erreur dans la formule, il suffira de le corriger qu'une seule fois, dans la fonction convert_fahrenheit_to_celsius().","title":"Fonctions"},{"location":"Python/fonction/#fonctions","text":"","title":"Fonctions"},{"location":"Python/fonction/#principe-et-generalites","text":"En programmation, les fonctions sont tr\u00e8s utiles pour r\u00e9aliser plusieurs fois la m\u00eame op\u00e9ration au sein d'un programme. Elles rendent \u00e9galement le code plus lisible et plus clair en le fractionnant en blocs logiques. Vous connaissez d\u00e9j\u00e0 certaines fonctions Python . Par exemple math.cos(angle) du module math renvoie le cosinus de la variable angle exprim\u00e9 en radian. Vous connaissez aussi des fonctions internes \u00e0 Python comme range() ou len() . Pour l'instant, une fonction est \u00e0 vos yeux une sorte de \u00ab bo\u00eete noire \u00bb (voir figure 1) : \u00c0 laquelle vous passez aucune, une ou plusieurs variable(s) entre parenth\u00e8ses. Ces variables sont appel\u00e9es arguments . Il peut s'agir de n'importe quel type d'objet Python. Qui effectue une action. Et qui renvoie un objet Python ou rien du tout. Fonctionnement sch\u00e9matique d'une fonction. Par exemple, si vous appelez la fonction len() de la mani\u00e8re suivante : 1 2 >>> len ([ 0 , 1 , 2 ]) 3 voici ce qui se passe : vous appelez len() en lui passant une liste en argument (ici la liste [0, 1, 2] ) ; la fonction calcule la longueur de cette liste ; elle vous renvoie un entier \u00e9gal \u00e0 cette longueur. Autre exemple, si vous appelez la m\u00e9thode ma_liste.append() (n'oubliez pas, une m\u00e9thode est une fonction qui agit sur l'objet auquel elle est attach\u00e9e par un point) : 1 >>> ma_liste . append ( 5 ) Vous passez l'entier 5 en argument ; la m\u00e9thode append() ajoute l'entier 5 \u00e0 l'objet ma_liste ; et elle ne renvoie rien. Aux yeux du programmeur au contraire, une fonction est une portion de code effectuant une suite d'instructions bien particuli\u00e8re. Mais avant de vous pr\u00e9senter la syntaxe et la mani\u00e8re de construire une fonction, revenons une derni\u00e8re fois sur cette notion de \u00ab bo\u00eete noire \u00bb : Une fonction effectue une t\u00e2che. Pour cela, elle re\u00e7oit \u00e9ventuellement des arguments et renvoie \u00e9ventuellement quelque chose. L'algorithme utilis\u00e9 au sein de la fonction n'int\u00e9resse pas directement l'utilisateur. Par exemple, il est inutile de savoir comment la fonction math.cos() calcule un cosinus. On a juste besoin de savoir qu'il faut lui passer en argument un angle en radian et qu'elle renvoie le cosinus de cet angle. Ce qui se passe \u00e0 l'int\u00e9rieur de la fonction ne regarde que le programmeur. Chaque fonction effectue en g\u00e9n\u00e9ral une t\u00e2che unique et pr\u00e9cise. Si cela se complique, il est plus judicieux d'\u00e9crire plusieurs fonctions (qui peuvent \u00e9ventuellement s'appeler les unes les autres). Cette modularit\u00e9 am\u00e9liore la qualit\u00e9 g\u00e9n\u00e9rale et la lisibilit\u00e9 du code. Vous verrez qu'en Python, les fonctions pr\u00e9sentent une grande flexibilit\u00e9. Pour finir sur les g\u00e9n\u00e9ralit\u00e9s, nous avons utilis\u00e9 dans la Figure 1 le terme programme principal ( main en anglais) pour d\u00e9signer l'endroit depuis lequel on appelle une fonction (on verra plus tard que l'on peut en fait appeler une fonction de n'importe o\u00f9). Le programme principal d\u00e9signe le code qui est ex\u00e9cut\u00e9 lorsqu'on lance le script Python , c'est-\u00e0-dire toute la suite d'instructions en dehors des fonctions. En g\u00e9n\u00e9ral, dans un script Python , on \u00e9crit d'abord les fonctions puis le programme principal. Nous aurons l'occasion de revenir sur cette notion de programme principal plus tard dans ce chapitre ainsi que dans le chapitre 12 Plus sur les fonctions .","title":"Principe et g\u00e9n\u00e9ralit\u00e9s"},{"location":"Python/fonction/#definition","text":"Pour d\u00e9finir une fonction, Python utilise le mot-cl\u00e9 def . Si on souhaite que la fonction renvoie quelque chose, il faut utiliser le mot-cl\u00e9 return . Par exemple : 1 2 3 4 5 >>> def carre ( x ): ... return x ** 2 ... >>> print ( carre ( 2 )) 4 Notez que la syntaxe de def utilise les deux-points comme les boucles for et while ainsi que les tests if , un bloc d\u2019instructions est donc attendu. De m\u00eame que pour les boucles et les tests, l' indentation de ce bloc d'instructions (qu'on appelle le corps de la fonction) est obligatoire . Dans l'exemple pr\u00e9c\u00e9dent, nous avons pass\u00e9 un argument \u00e0 la fonction carre() qui nous a renvoy\u00e9 (ou retourn\u00e9) une valeur que nous avons imm\u00e9diatement affich\u00e9e \u00e0 l'\u00e9cran avec l'instruction print() . Que veut dire valeur renvoy\u00e9e ? Et bien cela signifie que cette derni\u00e8re est r\u00e9cup\u00e9rable dans une variable : 1 2 3 >>> res = carre ( 2 ) >>> print ( res ) 4 Ici, le r\u00e9sultat renvoy\u00e9 par la fonction est stock\u00e9 dans la variable res . Notez qu'une fonction ne prend pas forc\u00e9ment un argument et ne renvoie pas forc\u00e9ment une valeur, par exemple : 1 2 3 4 5 >>> def hello (): ... print ( \"bonjour\" ) ... >>> hello () bonjour Dans ce cas la fonction, hello() se contente d'afficher la cha\u00eene de caract\u00e8res \"bonjour\" \u00e0 l'\u00e9cran. Elle ne prend aucun argument et ne renvoie rien. Par cons\u00e9quent, cela n'a pas de sens de vouloir r\u00e9cup\u00e9rer dans une variable le r\u00e9sultat renvoy\u00e9 par une telle fonction. Si on essaie tout de m\u00eame, Python affecte la valeur None qui signifie rien en anglais: 1 2 3 4 >>> var = hello () bonjour >>> print ( var ) None Ceci n'est pas une faute car Python n'\u00e9met pas d'erreur, toutefois cela ne pr\u00e9sente, la plupart du temps, gu\u00e8re d'int\u00e9r\u00eat.","title":"D\u00e9finition"},{"location":"Python/fonction/#passage-darguments","text":"Le nombre d'arguments que l'on peut passer \u00e0 une fonction est variable. Nous avons vu ci-dessus des fonctions auxquelles on passait 0 ou 1 argument. Dans les chapitres pr\u00e9c\u00e9dents, vous avez rencontr\u00e9 des fonctions internes \u00e0 Python qui prenaient au moins 2 arguments. Souvenez-vous par exemple de range(1, 10) ou encore range(1, 10, 2) . Le nombre d'argument est donc laiss\u00e9 libre \u00e0 l'initiative du programmeur qui d\u00e9veloppe une nouvelle fonction. Une particularit\u00e9 des fonctions en Python est que vous n'\u00eates pas oblig\u00e9 de pr\u00e9ciser le type des arguments que vous lui passez, d\u00e8s lors que les op\u00e9rations que vous effectuez avec ces arguments sont valides. Python est en effet connu comme \u00e9tant un langage au \u00ab typage dynamique \u00bb, c'est-\u00e0-dire qu'il reconna\u00eet pour vous le type des variables au moment de l'ex\u00e9cution. Par exemple : 1 2 3 4 5 6 7 8 9 10 11 >>> def fois(x, y): ... return x*y ... >>> fois(2, 3) 6 >>> fois(3.1415, 5.23) 16.430045000000003 >>> fois(\"to\", 2) 'toto' >>> fois([1,3], 2) [1, 3, 1, 3] L'op\u00e9rateur * reconna\u00eet plusieurs types (entiers, floats , cha\u00eenes de caract\u00e8res, listes). Notre fonction fois() est donc capable d'effectuer des t\u00e2ches diff\u00e9rentes ! M\u00eame si Python autorise cela, m\u00e9fiez-vous tout de m\u00eame de cette grande flexibilit\u00e9 qui pourrait conduire \u00e0 des surprises dans vos futurs programmes. En g\u00e9n\u00e9ral, il est plus judicieux que chaque argument ait un type pr\u00e9cis (entiers, floats , cha\u00eenes de caract\u00e8res, etc) et pas l'un ou l'autre.","title":"Passage d'arguments"},{"location":"Python/fonction/#renvoi-de-resultats","text":"Un \u00e9norme avantage en Python est que les fonctions sont capables de renvoyer plusieurs objets \u00e0 la fois, comme dans cette fraction de code : 1 2 3 4 5 >>> def carre_cube ( x ): ... return x ** 2 , x ** 3 ... >>> carre_cube ( 2 ) ( 4 , 8 ) En r\u00e9alit\u00e9 Python ne renvoie qu'un seul objet, mais celui-ci peut \u00eatre s\u00e9quentiel, c'est-\u00e0-dire contenir lui m\u00eame d'autres objets. Dans notre exemple Python renvoie un objet de type tuple , type que nous verrons dans le chapitre 13 Dictionnaires et tuples (grosso modo, il s'agit d'une sorte de liste avec des propri\u00e9t\u00e9s diff\u00e9rentes). Notre fonction pourrait tout autant renvoyer une liste : 1 2 3 4 5 >>> def carre_cube2 ( x ): ... return [ x ** 2 , x ** 3 ] ... >>> carre_cube2 ( 3 ) [ 9 , 27 ] Renvoyer un tuple ou une liste de deux \u00e9l\u00e9ments (ou plus) est tr\u00e8s pratique en conjonction avec l' affectation multiple , par exemple : 1 2 3 4 5 >>> z1 , z2 = carre_cube2 ( 3 ) >>> z1 9 >>> z2 27 Cela permet de r\u00e9cup\u00e9rer plusieurs valeurs renvoy\u00e9es par une fonction et de les affecter \u00e0 la vol\u00e9e \u00e0 des variables diff\u00e9rentes.","title":"Renvoi de r\u00e9sultats"},{"location":"Python/fonction/#arguments-positionnels-et-arguments-par-mot-cle","text":"Jusqu'\u00e0 maintenant, nous avons syst\u00e9matiquement pass\u00e9 le nombre d'arguments que la fonction attendait. Que se passe-t-il si une fonction attend deux arguments et que nous ne lui en passons qu'un seul ? 1 2 3 4 5 6 7 8 9 >>> def fois ( x , y ): ... return x * y ... >>> fois ( 2 , 3 ) 6 >>> fois ( 2 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : fois () missing 1 required positional argument : 'y' On constate que passer un seul argument \u00e0 une fonction qui en attend deux conduit \u00e0 une erreur. D\u00e9finition Lorsqu'on d\u00e9finit une fonction def fct(x, y): les arguments x et y sont appel\u00e9s arguments positionnels (en anglais positional arguments ). Il est strictement obligatoire de les pr\u00e9ciser lors de l'appel de la fonction. De plus, il est n\u00e9cessaire de respecter le m\u00eame ordre lors de l'appel que dans la d\u00e9finition de la fonction. Dans l'exemple ci-dessus, 2 correspondra \u00e0 x et 3 correspondra \u00e0 y . Finalement, tout d\u00e9pendra de leur position, d'o\u00f9 leur qualification de positionnel. Mais il est aussi possible de passer un ou plusieurs argument(s) de mani\u00e8re facultative et de leur attribuer une valeur par d\u00e9faut : 1 2 3 4 5 6 7 >>> def fct ( x = 1 ): ... return x ... >>> fct () 1 >>> fct ( 10 ) 10 D\u00e9finition Un argument d\u00e9fini avec une syntaxe def fct(arg=val): est appel\u00e9 argument par mot-cl\u00e9 (en anglais keyword argument). Le passage d'un tel argument lors de l'appel de la fonction est facultatif. Ce type d'argument ne doit pas \u00eatre confondu avec les arguments positionnels pr\u00e9sent\u00e9s ci-dessus, dont la syntaxe est def fct(arg):. Il est bien s\u00fbr possible de passer plusieurs arguments par mot-cl\u00e9 : def fct(x=0, y=0, z=0): ... return x, y, z ... fct() (0, 0, 0) fct(10) (10, 0, 0) fct(10, 8) (10, 8, 0) fct(10, 8, 3) (10, 8, 3) On observe que pour l'instant, les arguments par mot-cl\u00e9 sont pris dans l'ordre dans lesquels on les passe lors de l'appel. Comment pourrions-nous faire si on souhaitait pr\u00e9ciser l'argument par mot-cl\u00e9 z et garder les valeurs de x et y par d\u00e9faut ? Simplement en pr\u00e9cisant le nom de l'argument lors de l'appel : fct(z=10) (0, 0, 10) Python permet m\u00eame de rentrer les arguments par mot-cl\u00e9 dans un ordre arbitraire : fct(z=10, x=3, y=80) (3, 80, 10) fct(z=10, y=80) (0, 80, 10) Que se passe-t-il lorsque nous avons un m\u00e9lange d'arguments positionnels et par mot-cl\u00e9 ? Et bien les arguments positionnels doivent toujours \u00eatre plac\u00e9s avant les arguments par mot-cl\u00e9 : def fct(a, b, x=0, y=0, z=0): ... return a, b, x, y, z ... fct(1, 1) (1, 1, 0, 0, 0) fct(1, 1, z=5) (1, 1, 0, 0, 5) fct(1, 1, z=5, y=32) (1, 1, 0, 32, 5) On peut toujours passer les arguments par mot-cl\u00e9 dans un ordre arbitraire \u00e0 partir du moment o\u00f9 on pr\u00e9cise leur nom. Par contre, si les deux arguments positionnels a et b ne sont pas pass\u00e9s \u00e0 la fonction, Python renvoie une erreur. fct(z=0) Traceback (most recent call last): File \" \", line 1, in TypeError: fct() missing 2 required positional arguments: 'a' and 'b' Conseils Pr\u00e9ciser le nom des arguments par mot-cl\u00e9 lors de l'appel d'une fonction est une pratique que nous vous recommandons. Cela les distingue clairement des arguments positionnels. L'utilisation d'arguments par mot-cl\u00e9 est habituelle en Python. Elle permet de modifier le comportement par d\u00e9faut de nombreuses fonctions. Par exemple, si on souhaite que la fonction print() n'affiche pas un retour \u00e0 la ligne, on peut utiliser l'argument end : print(\"Message \", end=\"\") Message >>> Nous verrons, dans le chapitre 20 Fen\u00eatres graphiques et Tkinter, que l'utilisation d'arguments par mot-cl\u00e9 est syst\u00e9matique lorsqu'on cr\u00e9e un objet graphique (une fen\u00eatre, un bouton, etc.). 9.6 Variables locales et variables globales Lorsqu'on manipule des fonctions, il est essentiel de bien comprendre comment se comportent les variables. Une variable est dite locale lorsqu'elle est cr\u00e9\u00e9e dans une fonction. Elle n'existera et ne sera visible que lors de l'ex\u00e9cution de ladite fonction. Une variable est dite globale lorsqu'elle est cr\u00e9\u00e9e dans le programme principal. Elle sera visible partout dans le programme. Ceci ne vous para\u00eet pas clair ? Nous allons prendre un exemple simple qui vous aidera \u00e0 mieux saisir ces concepts. Observez le code suivant :","title":"Arguments positionnels et arguments par mot-cl\u00e9"},{"location":"Python/fonction/#definition-dune-fonction-carre","text":"def carre(x): y = x**2 return y","title":"d\u00e9finition d'une fonction carre()"},{"location":"Python/fonction/#programme-principal","text":"z = 5 resultat = carre(z) print(resultat) Pour la suite des explications, nous allons utiliser l'excellent site Python Tutor qui permet de visualiser l'\u00e9tat des variables au fur et \u00e0 mesure de l'ex\u00e9cution d'un code Python. Avant de poursuivre, nous vous conseillons de prendre 5 minutes pour tester ce site. Regardons maintenant ce qui se passe dans le code ci-dessus, \u00e9tape par \u00e9tape : 1 \u00c9tape 1 : Python est pr\u00eat \u00e0 lire la premi\u00e8re ligne de code. \u00c9tape 1. Figure 2. \u00c9tape 1. 1 \u00c9tape 2 : Python met en m\u00e9moire la fonction carre(). Notez qu'il ne l'ex\u00e9cute pas ! La fonction est mise dans un espace de la m\u00e9moire nomm\u00e9 Global frame, il s'agit de l'espace du programme principal. Dans cet espace, seront stock\u00e9es toutes les variables globales cr\u00e9\u00e9es dans le programme. Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter le programme principal. \u00c9tape 2. Figure 3. \u00c9tape 2. 1 \u00c9tape 3 : Python lit et met en m\u00e9moire la variable z. Celle-ci \u00e9tant cr\u00e9\u00e9e dans le programme principal, il s'agira d'une variable globale. Ainsi, elle sera \u00e9galement stock\u00e9e dans le Global frame. \u00c9tape 3. Figure 4. \u00c9tape 3. 1 \u00c9tape 4 : La fonction carre() est appel\u00e9e et on lui passe en argument l'entier z. La fonction s'ex\u00e9cute et un nouveau cadre est cr\u00e9\u00e9 dans lequel Python Tutor va indiquer toutes les variables locales \u00e0 la fonction. Notez bien que la variable pass\u00e9e en argument, qui s'appelle x dans la fonction, est cr\u00e9\u00e9e en tant que variable locale. On remarquera aussi que les variables globales situ\u00e9es dans le Global frame sont toujours l\u00e0. \u00c9tape 4. Figure 5. \u00c9tape 4. 1 \u00c9tape 5 : Python est maintenant pr\u00eat \u00e0 ex\u00e9cuter chaque ligne de code de la fonction. \u00c9tape 5. Figure 6. \u00c9tape 5. 1 \u00c9tape 6 : La variable y est cr\u00e9\u00e9e dans la fonction. Celle-ci est donc stock\u00e9e en tant que variable locale \u00e0 la fonction. \u00c9tape 6. Figure 7. \u00c9tape 6. 1 \u00c9tape 7 : Python s'appr\u00eate \u00e0 renvoyer la variable locale y au programme principal. Python Tutor nous indique le contenu de la valeur renvoy\u00e9e. \u00c9tape 7. Figure 8. \u00c9tape 7. 1 \u00c9tape 8 : Python quitte la fonction et la valeur renvoy\u00e9e par celle-ci est affect\u00e9e \u00e0 la variable globale resultat. Notez bien que lorsque Python quitte la fonction, l'espace des variables allou\u00e9 \u00e0 la fonction est d\u00e9truit. Ainsi, toutes les variables cr\u00e9\u00e9es dans la fonction n'existent plus. On comprend pourquoi elles portent le nom de locales puisqu'elles n'existent que lorsque la fonction est ex\u00e9cut\u00e9e. \u00c9tape 8. Figure 9. \u00c9tape 8. 1 \u00c9tape 9 : Python affiche le contenu de la variable resultat et l'ex\u00e9cution est termin\u00e9e. \u00c9tape 9. Figure 10. \u00c9tape 9. Nous esp\u00e9rons que cet exemple guid\u00e9 facilitera la compr\u00e9hension des concepts de variables locales et globales. Cela viendra aussi avec la pratique. Nous irons un peu plus loin sur les fonctions dans le chapitre 12. D'ici l\u00e0, essayez de vous entra\u00eener au maximum avec les fonctions. C'est un concept ardu, mais il est imp\u00e9ratif de le ma\u00eetriser. Enfin, comme vous avez pu le constater, Python Tutor nous a grandement aid\u00e9 \u00e0 comprendre ce qui se passait. N'h\u00e9sitez pas \u00e0 l'utiliser sur des exemples ponctuels, ce site vous aidera \u00e0 visualiser ce qui se passe lorsqu'un code ne fait pas ce que vous attendez. 9.7 Principe DRY L'acronyme DRY signifie Don't Repeat Yourself. Les fonctions permettent de satisfaire ce principe en \u00e9vitant la duplication de code. En effet, plus un code est dupliqu\u00e9 plusieurs fois dans un programme, plus il sera source d'erreurs, notamment lorsqu'il faudra le faire \u00e9voluer. Consid\u00e9rons par exemple le code suivant qui convertit plusieurs temp\u00e9ratures des degr\u00e9s Fahrenheit en degr\u00e9s Celsius : temp_in_fahrenheit = 60 (temp_in_fahrenheit - 32) * (5/8) 17.5 temp_in_fahrenheit = 80 (temp_in_fahrenheit - 32) * (5/8) 30.0 temp_in_fahrenheit = 100 (temp_in_fahrenheit - 32) * (5/8) 42.5 Malheureusement il y a une erreur dans la formule de conversion. En effet la formule exacte est : temp_celsius=(temp_fahrenheit\u221232)\u00d759 Il faut alors reprendre les lignes 2, 5 et 8 pr\u00e9c\u00e9dentes et les corriger. Cela n'est pas efficace, surtout si le m\u00eame code est utilis\u00e9 \u00e0 diff\u00e9rents endroits dans le programme. En \u00e9crivant qu'une seule fois la formule de conversion dans une fonction, on applique le principe DRY : def convert_fahrenheit_to_celsius(temperature): ... return (temperature - 32) * (5/9) ... temp_in_fahrenheit = 60 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 15.555555555555557 temp_in_fahrenheit = 80 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 26.666666666666668 temp_in_fahrenheit = 100 convert_fahrenheit_to_celsius(temp_in_fahrenheit) 37.77777777777778 Et s'il y a une erreur dans la formule, il suffira de le corriger qu'une seule fois, dans la fonction convert_fahrenheit_to_celsius().","title":"programme principal"},{"location":"Python/listes/","text":"Listes D\u00e9finition Une liste est une structure de donn\u00e9es qui contient une s\u00e9rie de valeurs. Python autorise la construction de liste contenant des valeurs de types diff\u00e9rents (par exemple entier et cha\u00eene de caract\u00e8res), ce qui leur conf\u00e8re une grande flexibilit\u00e9. Une liste est d\u00e9clar\u00e9e par une s\u00e9rie de valeurs (n'oubliez pas les guillemets, simples ou doubles, s'il s'agit de cha\u00eenes de caract\u00e8res) s\u00e9par\u00e9es par des virgules , et le tout encadr\u00e9 par des crochets . En voici quelques exemples : 1 2 3 4 5 6 7 8 9 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> tailles = [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte = [ \"girafe\" , 5 , \"souris\" , 0.15 ] >>> animaux [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> tailles [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte [ 'girafe' , 5 , 'souris' , 0.15 ] Lorsque l'on affiche une liste, Python la restitue telle qu'elle a \u00e9t\u00e9 saisie. Utilisation Un des gros avantages d'une liste est que vous pouvez appeler ses \u00e9l\u00e9ments par leur position. Ce num\u00e9ro est appel\u00e9 indice (ou index) de la liste. 1 2 liste : [\"girafe\", \"tigre\", \"singe\", \"souris\"] indice : 0 1 2 3 Soyez tr\u00e8s attentifs au fait que les indices d'une liste de n \u00e9l\u00e9ments commence \u00e0 0 et se termine \u00e0 n-1 . Voyez l'exemple suivant : 1 2 3 4 5 6 7 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 ] 'girafe' >>> animaux [ 1 ] 'tigre' >>> animaux [ 3 ] 'souris' Par cons\u00e9quent, si on appelle l'\u00e9l\u00e9ment d'indice 4 de notre liste, Python renverra un message d'erreur : 1 2 3 4 >>> animaux[4] Traceback (innermost last): File \"<stdin>\", line 1, in ? IndexError: list index out of range N'oubliez pas ceci ou vous risquez d'obtenir des bugs inattendus ! Op\u00e9ration sur les listes Tout comme les cha\u00eenes de caract\u00e8res, les listes supportent l'op\u00e9rateur + de concat\u00e9nation, ainsi que l'op\u00e9rateur * pour la duplication : 1 2 3 4 5 6 >>> ani1 = [ \"girafe\" , \"tigre\" ] >>> ani2 = [ \"singe\" , \"souris\" ] >>> ani1 + ani2 [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> ani1 * 3 [ 'girafe' , 'tigre' , 'girafe' , 'tigre' , 'girafe' , 'tigre' ] L'op\u00e9rateur + est tr\u00e8s pratique pour concat\u00e9ner deux listes. Vous pouvez aussi utiliser la m\u00e9thode .append() lorsque vous souhaitez ajouter un seul \u00e9l\u00e9ment \u00e0 la fin d'une liste. Dans l'exemple suivant nous allons cr\u00e9er une liste vide : 1 2 3 >>> a = [] >>> a [] puis lui ajouter deux \u00e9l\u00e9ments, l'un apr\u00e8s l'autre, d'abord avec la concat\u00e9nation : 1 2 3 4 5 6 >>> a = a + [15] >>> a [15] >>> a = a + [-5] >>> a [15, -5] puis avec la m\u00e9thode .append() : 1 2 3 4 5 6 >>> a.append(13) >>> a [15, -5, 13] >>> a.append(-3) >>> a [15, -5, 13, -3] Dans l'exemple ci-dessus, nous ajoutons des \u00e9l\u00e9ments \u00e0 une liste en utilisant l'op\u00e9rateur de concat\u00e9nation + ou la m\u00e9thode .append() . Nous vous conseillons dans ce cas pr\u00e9cis d'utiliser la m\u00e9thode .append() dont la syntaxe est plus \u00e9l\u00e9gante. Nous reverrons en d\u00e9tail la m\u00e9thode .append() dans le chapitre 11 Plus sur les listes. Indi\u00e7age n\u00e9gatif La liste peut \u00e9galement \u00eatre index\u00e9e avec des nombres n\u00e9gatifs selon le mod\u00e8le suivant : 1 2 3 liste : [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] indice positif : 0 1 2 3 indice n\u00e9gatif : - 4 - 3 - 2 - 1 ou encore : 1 2 3 liste : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" ] indice positif : 0 1 2 3 4 5 indice n\u00e9gatif : - 6 - 5 - 4 - 3 - 2 - 1 Les indices n\u00e9gatifs reviennent \u00e0 compter \u00e0 partir de la fin. Leur principal avantage est que vous pouvez acc\u00e9der au dernier \u00e9l\u00e9ment d'une liste \u00e0 l'aide de l'indice -1 sans pour autant conna\u00eetre la longueur de cette liste. L'avant-dernier \u00e9l\u00e9ment a lui l'indice -2 , l'avant-avant dernier l'indice -3 , etc. 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ - 1 ] 'souris' >>> animaux [ - 2 ] 'singe' Pour acc\u00e9der au premier \u00e9l\u00e9ment de la liste avec un indice n\u00e9gatif, il faut par contre conna\u00eetre le bon indice : 1 2 >>> animaux [ - 4 ] 'girafe' Dans ce cas, on utilise plut\u00f4t animaux[0] . Tranches Un autre avantage des listes est la possibilit\u00e9 de s\u00e9lectionner une partie d'une liste en utilisant un indi\u00e7age construit sur le mod\u00e8le [m:n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l'\u00e9l\u00e9ment m inclus \u00e0 l'\u00e9l\u00e9ment n+1 exclu). On dit alors qu'on r\u00e9cup\u00e8re une tranche de la liste, par exemple : 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 2 ] [ 'girafe' , 'tigre' ] >>> animaux [ 0 : 3 ] [ 'girafe' , 'tigre' , 'singe' ] >>> animaux [ 0 :] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [:] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 :] [ 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 : - 1 ] [ 'tigre' , 'singe' ] Notez que lorsqu'aucun indice n'est indiqu\u00e9 \u00e0 gauche ou \u00e0 droite du symbole deux-points, Python prend par d\u00e9faut tous les \u00e9l\u00e9ments depuis le d\u00e9but ou tous les \u00e9l\u00e9ments jusqu'\u00e0 la fin respectivement. On peut aussi pr\u00e9ciser le pas en ajoutant un symbole deux-points suppl\u00e9mentaire et en indiquant le pas par un entier. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 3 : 2 ] [ 'girafe' , 'singe' ] >>> x = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 1 ] [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 2 ] [ 0 , 2 , 4 , 6 , 8 ] >>> x [:: 3 ] [ 0 , 3 , 6 , 9 ] >>> x [ 1 : 6 : 3 ] [ 1 , 4 ] Finalement, on se rend compte que l'acc\u00e8s au contenu d'une liste fonctionne sur le mod\u00e8le liste[d\u00e9but:fin:pas] . Fonction len() L'instruction len() vous permet de conna\u00eetre la longueur d'une liste, c'est-\u00e0-dire le nombre d'\u00e9l\u00e9ments que contient la liste. Voici un exemple d'utilisation : 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> len ( animaux ) 4 >>> len ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) 8 Les fonctions range() et list() L'instruction range() est une fonction sp\u00e9ciale en Python qui g\u00e9n\u00e8re des nombres entiers compris dans un intervalle. Lorsqu'elle est utilis\u00e9e en combinaison avec la fonction list() , on obtient une liste d'entiers. Par exemple : 1 2 >>> list ( range ( 10 )) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] La commande list(range(10)) a g\u00e9n\u00e9r\u00e9 une liste contenant tous les nombres entiers de 0 inclus \u00e0 10 exclu . Nous verrons l'utilisation de la fonction range() toute seule dans le chapitre 5 Boucles et comparaisons. Dans l'exemple ci-dessus, la fonction range() a pris un argument, mais elle peut \u00e9galement prendre deux ou trois arguments, voyez plut\u00f4t : 1 2 3 4 5 6 7 8 >>> list ( range ( 0 , 5 )) [ 0 , 1 , 2 , 3 , 4 ] >>> list ( range ( 15 , 20 )) [ 15 , 16 , 17 , 18 , 19 ] >>> list ( range ( 0 , 1000 , 200 )) [ 0 , 200 , 400 , 600 , 800 ] >>> list ( range ( 2 , - 2 , - 1 )) [ 2 , 1 , 0 , - 1 ] L'instruction range() fonctionne sur le mod\u00e8le range([d\u00e9but,] fin[, pas]) . Les arguments entre crochets sont optionnels. Pour obtenir une liste de nombres entiers, il faut l'utiliser syst\u00e9matiquement avec la fonction list() . Enfin, prenez garde aux arguments optionnels par d\u00e9faut ( 0 pour d\u00e9but et 1 pour pas) : 1 2 >>> list ( range ( 10 , 0 )) [] Ici la liste est vide car Python a pris la valeur du pas par d\u00e9faut qui est de 1 . Ainsi, si on commence \u00e0 10 et qu'on avance par pas de 1 , on ne pourra jamais atteindre 0 . Python g\u00e9n\u00e8re ainsi une liste vide. Pour \u00e9viter \u00e7a, il faudrait, par exemple, pr\u00e9ciser un pas de -1 pour obtenir une liste d'entiers d\u00e9croissants : 1 2 >>> list ( range ( 10 , 0 , - 1 )) [ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ] Listes de listes Pour finir, sachez qu'il est tout \u00e0 fait possible de construire des listes de listes. Cette fonctionnalit\u00e9 peut parfois \u00eatre tr\u00e8s pratique. Par exemple : 1 2 3 4 5 6 >>> enclos1 = [ \"girafe\" , 4 ] >>> enclos2 = [ \"tigre\" , 2 ] >>> enclos3 = [ \"singe\" , 5 ] >>> zoo = [ enclos1 , enclos2 , enclos3 ] >>> zoo [[ 'girafe' , 4 ], [ 'tigre' , 2 ], [ 'singe' , 5 ]] Dans cet exemple, chaque sous-liste contient une cat\u00e9gorie d'animal et le nombre d'animaux pour chaque cat\u00e9gorie. Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la liste, on utilise l'indi\u00e7age habituel : 1 2 >>> zoo [ 1 ] [ 'tigre' , 2 ] Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la sous-liste, on utilise un double indi\u00e7age : 1 2 3 4 >>> zoo [ 1 ][ 0 ] 'tigre' >>> zoo [ 1 ][ 1 ] 2 On verra un peu plus loin qu'il existe en Python des dictionnaires qui sont \u00e9galement tr\u00e8s pratiques pour stocker de l'information structur\u00e9e. On verra aussi qu'il existe un module nomm\u00e9 NumPy qui permet de cr\u00e9er des listes ou des tableaux de nombres (vecteurs et matrices) et de les manipuler. Minimum, maximum et somme d'une liste Les fonctions min() , max() et sum() renvoient respectivement le minimum, le maximum et la somme d'une liste pass\u00e9e en argument. 1 2 3 4 5 6 7 8 9 >>> liste = list ( range ( 10 )) >>> liste [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> sum ( liste ) 45 >>> min ( liste ) 0 >>> max ( liste ) 9 M\u00eame si en th\u00e9orie ces fonctions peuvent prendre en argument une liste de strings , on les utilisera la plupart du temps avec des types num\u00e9riques (liste d'entiers et/ou de floats ). Nous avions d\u00e9j\u00e0 crois\u00e9 min() , max() dans le chapitre 2 Variables. On avait vu que ces deux fonctions pouvaient prendre plusieurs arguments entiers et / ou floats , par exemple : 1 2 >>> min ( 3 , 4 ) 3 Attention toutefois \u00e0 ne pas m\u00e9langer entiers et floats d'une part avec une liste d'autre part, car cela renvoie une erreur : 1 2 3 4 >>> min ( liste , 3 , 4 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'list' Soit on passe plusieurs entiers et/ou floats en argument, soit on passe une liste unique.","title":"Listes"},{"location":"Python/listes/#listes","text":"","title":"Listes"},{"location":"Python/listes/#definition","text":"Une liste est une structure de donn\u00e9es qui contient une s\u00e9rie de valeurs. Python autorise la construction de liste contenant des valeurs de types diff\u00e9rents (par exemple entier et cha\u00eene de caract\u00e8res), ce qui leur conf\u00e8re une grande flexibilit\u00e9. Une liste est d\u00e9clar\u00e9e par une s\u00e9rie de valeurs (n'oubliez pas les guillemets, simples ou doubles, s'il s'agit de cha\u00eenes de caract\u00e8res) s\u00e9par\u00e9es par des virgules , et le tout encadr\u00e9 par des crochets . En voici quelques exemples : 1 2 3 4 5 6 7 8 9 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> tailles = [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte = [ \"girafe\" , 5 , \"souris\" , 0.15 ] >>> animaux [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> tailles [ 5 , 2.5 , 1.75 , 0.15 ] >>> mixte [ 'girafe' , 5 , 'souris' , 0.15 ] Lorsque l'on affiche une liste, Python la restitue telle qu'elle a \u00e9t\u00e9 saisie.","title":"D\u00e9finition"},{"location":"Python/listes/#utilisation","text":"Un des gros avantages d'une liste est que vous pouvez appeler ses \u00e9l\u00e9ments par leur position. Ce num\u00e9ro est appel\u00e9 indice (ou index) de la liste. 1 2 liste : [\"girafe\", \"tigre\", \"singe\", \"souris\"] indice : 0 1 2 3 Soyez tr\u00e8s attentifs au fait que les indices d'une liste de n \u00e9l\u00e9ments commence \u00e0 0 et se termine \u00e0 n-1 . Voyez l'exemple suivant : 1 2 3 4 5 6 7 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 ] 'girafe' >>> animaux [ 1 ] 'tigre' >>> animaux [ 3 ] 'souris' Par cons\u00e9quent, si on appelle l'\u00e9l\u00e9ment d'indice 4 de notre liste, Python renverra un message d'erreur : 1 2 3 4 >>> animaux[4] Traceback (innermost last): File \"<stdin>\", line 1, in ? IndexError: list index out of range N'oubliez pas ceci ou vous risquez d'obtenir des bugs inattendus !","title":"Utilisation"},{"location":"Python/listes/#operation-sur-les-listes","text":"Tout comme les cha\u00eenes de caract\u00e8res, les listes supportent l'op\u00e9rateur + de concat\u00e9nation, ainsi que l'op\u00e9rateur * pour la duplication : 1 2 3 4 5 6 >>> ani1 = [ \"girafe\" , \"tigre\" ] >>> ani2 = [ \"singe\" , \"souris\" ] >>> ani1 + ani2 [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> ani1 * 3 [ 'girafe' , 'tigre' , 'girafe' , 'tigre' , 'girafe' , 'tigre' ] L'op\u00e9rateur + est tr\u00e8s pratique pour concat\u00e9ner deux listes. Vous pouvez aussi utiliser la m\u00e9thode .append() lorsque vous souhaitez ajouter un seul \u00e9l\u00e9ment \u00e0 la fin d'une liste. Dans l'exemple suivant nous allons cr\u00e9er une liste vide : 1 2 3 >>> a = [] >>> a [] puis lui ajouter deux \u00e9l\u00e9ments, l'un apr\u00e8s l'autre, d'abord avec la concat\u00e9nation : 1 2 3 4 5 6 >>> a = a + [15] >>> a [15] >>> a = a + [-5] >>> a [15, -5] puis avec la m\u00e9thode .append() : 1 2 3 4 5 6 >>> a.append(13) >>> a [15, -5, 13] >>> a.append(-3) >>> a [15, -5, 13, -3] Dans l'exemple ci-dessus, nous ajoutons des \u00e9l\u00e9ments \u00e0 une liste en utilisant l'op\u00e9rateur de concat\u00e9nation + ou la m\u00e9thode .append() . Nous vous conseillons dans ce cas pr\u00e9cis d'utiliser la m\u00e9thode .append() dont la syntaxe est plus \u00e9l\u00e9gante. Nous reverrons en d\u00e9tail la m\u00e9thode .append() dans le chapitre 11 Plus sur les listes.","title":"Op\u00e9ration sur les listes"},{"location":"Python/listes/#indicage-negatif","text":"La liste peut \u00e9galement \u00eatre index\u00e9e avec des nombres n\u00e9gatifs selon le mod\u00e8le suivant : 1 2 3 liste : [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] indice positif : 0 1 2 3 indice n\u00e9gatif : - 4 - 3 - 2 - 1 ou encore : 1 2 3 liste : [ \"A\" , \"B\" , \"C\" , \"D\" , \"E\" , \"F\" ] indice positif : 0 1 2 3 4 5 indice n\u00e9gatif : - 6 - 5 - 4 - 3 - 2 - 1 Les indices n\u00e9gatifs reviennent \u00e0 compter \u00e0 partir de la fin. Leur principal avantage est que vous pouvez acc\u00e9der au dernier \u00e9l\u00e9ment d'une liste \u00e0 l'aide de l'indice -1 sans pour autant conna\u00eetre la longueur de cette liste. L'avant-dernier \u00e9l\u00e9ment a lui l'indice -2 , l'avant-avant dernier l'indice -3 , etc. 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ - 1 ] 'souris' >>> animaux [ - 2 ] 'singe' Pour acc\u00e9der au premier \u00e9l\u00e9ment de la liste avec un indice n\u00e9gatif, il faut par contre conna\u00eetre le bon indice : 1 2 >>> animaux [ - 4 ] 'girafe' Dans ce cas, on utilise plut\u00f4t animaux[0] .","title":"Indi\u00e7age n\u00e9gatif"},{"location":"Python/listes/#tranches","text":"Un autre avantage des listes est la possibilit\u00e9 de s\u00e9lectionner une partie d'une liste en utilisant un indi\u00e7age construit sur le mod\u00e8le [m:n+1] pour r\u00e9cup\u00e9rer tous les \u00e9l\u00e9ments, du \u00e9mi\u00e8me au \u00e9ni\u00e8me (de l'\u00e9l\u00e9ment m inclus \u00e0 l'\u00e9l\u00e9ment n+1 exclu). On dit alors qu'on r\u00e9cup\u00e8re une tranche de la liste, par exemple : 1 2 3 4 5 6 7 8 9 10 11 12 13 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 2 ] [ 'girafe' , 'tigre' ] >>> animaux [ 0 : 3 ] [ 'girafe' , 'tigre' , 'singe' ] >>> animaux [ 0 :] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [:] [ 'girafe' , 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 :] [ 'tigre' , 'singe' , 'souris' ] >>> animaux [ 1 : - 1 ] [ 'tigre' , 'singe' ] Notez que lorsqu'aucun indice n'est indiqu\u00e9 \u00e0 gauche ou \u00e0 droite du symbole deux-points, Python prend par d\u00e9faut tous les \u00e9l\u00e9ments depuis le d\u00e9but ou tous les \u00e9l\u00e9ments jusqu'\u00e0 la fin respectivement. On peut aussi pr\u00e9ciser le pas en ajoutant un symbole deux-points suppl\u00e9mentaire et en indiquant le pas par un entier. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> animaux [ 0 : 3 : 2 ] [ 'girafe' , 'singe' ] >>> x = [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 1 ] [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> x [:: 2 ] [ 0 , 2 , 4 , 6 , 8 ] >>> x [:: 3 ] [ 0 , 3 , 6 , 9 ] >>> x [ 1 : 6 : 3 ] [ 1 , 4 ] Finalement, on se rend compte que l'acc\u00e8s au contenu d'une liste fonctionne sur le mod\u00e8le liste[d\u00e9but:fin:pas] .","title":"Tranches"},{"location":"Python/listes/#fonction-len","text":"L'instruction len() vous permet de conna\u00eetre la longueur d'une liste, c'est-\u00e0-dire le nombre d'\u00e9l\u00e9ments que contient la liste. Voici un exemple d'utilisation : 1 2 3 4 5 >>> animaux = [ \"girafe\" , \"tigre\" , \"singe\" , \"souris\" ] >>> len ( animaux ) 4 >>> len ([ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 ]) 8","title":"Fonction len()"},{"location":"Python/listes/#les-fonctions-range-et-list","text":"L'instruction range() est une fonction sp\u00e9ciale en Python qui g\u00e9n\u00e8re des nombres entiers compris dans un intervalle. Lorsqu'elle est utilis\u00e9e en combinaison avec la fonction list() , on obtient une liste d'entiers. Par exemple : 1 2 >>> list ( range ( 10 )) [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] La commande list(range(10)) a g\u00e9n\u00e9r\u00e9 une liste contenant tous les nombres entiers de 0 inclus \u00e0 10 exclu . Nous verrons l'utilisation de la fonction range() toute seule dans le chapitre 5 Boucles et comparaisons. Dans l'exemple ci-dessus, la fonction range() a pris un argument, mais elle peut \u00e9galement prendre deux ou trois arguments, voyez plut\u00f4t : 1 2 3 4 5 6 7 8 >>> list ( range ( 0 , 5 )) [ 0 , 1 , 2 , 3 , 4 ] >>> list ( range ( 15 , 20 )) [ 15 , 16 , 17 , 18 , 19 ] >>> list ( range ( 0 , 1000 , 200 )) [ 0 , 200 , 400 , 600 , 800 ] >>> list ( range ( 2 , - 2 , - 1 )) [ 2 , 1 , 0 , - 1 ] L'instruction range() fonctionne sur le mod\u00e8le range([d\u00e9but,] fin[, pas]) . Les arguments entre crochets sont optionnels. Pour obtenir une liste de nombres entiers, il faut l'utiliser syst\u00e9matiquement avec la fonction list() . Enfin, prenez garde aux arguments optionnels par d\u00e9faut ( 0 pour d\u00e9but et 1 pour pas) : 1 2 >>> list ( range ( 10 , 0 )) [] Ici la liste est vide car Python a pris la valeur du pas par d\u00e9faut qui est de 1 . Ainsi, si on commence \u00e0 10 et qu'on avance par pas de 1 , on ne pourra jamais atteindre 0 . Python g\u00e9n\u00e8re ainsi une liste vide. Pour \u00e9viter \u00e7a, il faudrait, par exemple, pr\u00e9ciser un pas de -1 pour obtenir une liste d'entiers d\u00e9croissants : 1 2 >>> list ( range ( 10 , 0 , - 1 )) [ 10 , 9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ]","title":"Les fonctions range() et list()"},{"location":"Python/listes/#listes-de-listes","text":"Pour finir, sachez qu'il est tout \u00e0 fait possible de construire des listes de listes. Cette fonctionnalit\u00e9 peut parfois \u00eatre tr\u00e8s pratique. Par exemple : 1 2 3 4 5 6 >>> enclos1 = [ \"girafe\" , 4 ] >>> enclos2 = [ \"tigre\" , 2 ] >>> enclos3 = [ \"singe\" , 5 ] >>> zoo = [ enclos1 , enclos2 , enclos3 ] >>> zoo [[ 'girafe' , 4 ], [ 'tigre' , 2 ], [ 'singe' , 5 ]] Dans cet exemple, chaque sous-liste contient une cat\u00e9gorie d'animal et le nombre d'animaux pour chaque cat\u00e9gorie. Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la liste, on utilise l'indi\u00e7age habituel : 1 2 >>> zoo [ 1 ] [ 'tigre' , 2 ] Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment de la sous-liste, on utilise un double indi\u00e7age : 1 2 3 4 >>> zoo [ 1 ][ 0 ] 'tigre' >>> zoo [ 1 ][ 1 ] 2 On verra un peu plus loin qu'il existe en Python des dictionnaires qui sont \u00e9galement tr\u00e8s pratiques pour stocker de l'information structur\u00e9e. On verra aussi qu'il existe un module nomm\u00e9 NumPy qui permet de cr\u00e9er des listes ou des tableaux de nombres (vecteurs et matrices) et de les manipuler.","title":"Listes de listes"},{"location":"Python/listes/#minimum-maximum-et-somme-dune-liste","text":"Les fonctions min() , max() et sum() renvoient respectivement le minimum, le maximum et la somme d'une liste pass\u00e9e en argument. 1 2 3 4 5 6 7 8 9 >>> liste = list ( range ( 10 )) >>> liste [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] >>> sum ( liste ) 45 >>> min ( liste ) 0 >>> max ( liste ) 9 M\u00eame si en th\u00e9orie ces fonctions peuvent prendre en argument une liste de strings , on les utilisera la plupart du temps avec des types num\u00e9riques (liste d'entiers et/ou de floats ). Nous avions d\u00e9j\u00e0 crois\u00e9 min() , max() dans le chapitre 2 Variables. On avait vu que ces deux fonctions pouvaient prendre plusieurs arguments entiers et / ou floats , par exemple : 1 2 >>> min ( 3 , 4 ) 3 Attention toutefois \u00e0 ne pas m\u00e9langer entiers et floats d'une part avec une liste d'autre part, car cela renvoie une erreur : 1 2 3 4 >>> min ( liste , 3 , 4 ) Traceback ( most recent call last ): File \"<stdin>\" , line 1 , in < module > TypeError : '<' not supported between instances of 'int' and 'list' Soit on passe plusieurs entiers et/ou floats en argument, soit on passe une liste unique.","title":"Minimum, maximum et somme d'une liste"},{"location":"Python/tests/","text":"Tests D\u00e9finition Les tests sont un \u00e9l\u00e9ment essentiel \u00e0 tout langage informatique si on veut lui donner un peu de complexit\u00e9 car ils permettent \u00e0 l'ordinateur de prendre des d\u00e9cisions. Pour cela, Python utilise l'instruction if ainsi qu'une comparaison que nous avons abord\u00e9e au chapitre pr\u00e9c\u00e9dent. Voici un premier exemple : 1 2 3 4 5 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... Le test est vrai ! et un second : 1 2 3 4 >>> x = \"souris\" >>> if x == \"tigre\" : ... print ( \"Le test est vrai !\" ) ... Il y a plusieurs remarques \u00e0 faire concernant ces deux exemples : Dans le premier exemple, le test \u00e9tant vrai, l'instruction print(\"Le test est vrai !\") est ex\u00e9cut\u00e9e. Dans le second exemple, le test est faux et rien n'est affich\u00e9. Les blocs d'instructions dans les tests doivent forc\u00e9ment \u00eatre indent\u00e9s comme pour les boucles for et while . L'indentation indique la port\u00e9e des instructions \u00e0 ex\u00e9cuter si le test est vrai. Comme avec les boucles for et while , la ligne qui contient l'instruction if se termine par le caract\u00e8re deux-points \u00ab : \u00bb. Tests \u00e0 plusieurs cas Parfois, il est pratique de tester si la condition est vraie ou si elle est fausse dans une m\u00eame instruction if . Plut\u00f4t que d'utiliser deux instructions if , on peut se servir des instructions if et else : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est vrai ! >>> x = 3 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est faux ! On peut utiliser une s\u00e9rie de tests dans la m\u00eame instruction if , notamment pour tester plusieurs valeurs d'une m\u00eame variable. Par exemple, on se propose de tirer au sort une base d'ADN puis d'afficher le nom de cette derni\u00e8re. Dans le code suivant, nous utilisons l'instruction random.choice(liste) qui renvoie un \u00e9l\u00e9ment choisi au hasard dans une liste. L'instruction import random sera vue plus tard dans le chapitre 8 Modules , admettez pour le moment qu'elle est n\u00e9cessaire. 1 2 3 4 5 6 7 8 9 10 11 12 >>> import random >>> base = random . choice ([ \"a\" , \"t\" , \"c\" , \"g\" ]) >>> if base == \"a\" : ... print ( \"choix d'une ad\u00e9nine\" ) ... elif base == \"t\" : ... print ( \"choix d'une thymine\" ) ... elif base == \"c\" : ... print ( \"choix d'une cytosine\" ) ... elif base == \"g\" : ... print ( \"choix d'une guanine\" ) ... choix d 'une cytosine Dans cet exemple, Python teste la premi\u00e8re condition, puis, si et seulement si elle est fausse, teste la deuxi\u00e8me et ainsi de suite... Le code correspondant \u00e0 la premi\u00e8re condition v\u00e9rifi\u00e9e est ex\u00e9cut\u00e9 puis Python sort du bloc d'instructions du if . Importance de l'indentation De nouveau, faites bien attention \u00e0 l'indentation ! Vous devez \u00eatre tr\u00e8s rigoureux sur ce point. Pour vous en convaincre, ex\u00e9cutez ces deux exemples de code : Code 1 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 Le test est vrai car la variable nb vaut 5 Code 2 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 3 4 car la variable nb vaut 4 Le test est vrai car la variable nb vaut 5 car la variable nb vaut 6 Les deux codes pourtant tr\u00e8s similaires produisent des r\u00e9sultats tr\u00e8s diff\u00e9rents. Si vous observez avec attention l'indentation des instructions sur la ligne 5, vous remarquerez que dans le code 1, l'instruction est indent\u00e9e deux fois, ce qui signifie qu'elle appartient au bloc d'instructions du test if . Dans le code 2, l'instruction de la ligne 5 n'est indent\u00e9e qu'une seule fois, ce qui fait qu'elle n'appartient plus au bloc d'instructions du test if , d'o\u00f9 l'affichage de car la variable nb vaut xx pour toutes les valeurs de nb . Tests multiples Les tests multiples permettent de tester plusieurs conditions en m\u00eame temps en utilisant des op\u00e9rateurs bool\u00e9ens. Les deux op\u00e9rateurs les plus couramment utilis\u00e9s sont le OU et le ET . Voici un petit rappel sur le fonctionnement de l'op\u00e9rateur OU : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai OU Vrai Vrai Vrai OU Faux Vrai Faux OU Vrai Vrai Faux OU Faux Faux et de l'op\u00e9rateur ET : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai ET Vrai Vrai Vrai ET Faux Faux Faux ET Vrai Faux Faux ET Faux Faux En Python , on utilise le mot r\u00e9serv\u00e9 and pour l'op\u00e9rateur ET et le mot r\u00e9serv\u00e9 or pour l'op\u00e9rateur OU . Respectez bien la casse des op\u00e9rateurs and et or qui, en Python , s'\u00e9crivent en minuscule. En voici un exemple d'utilisation : 1 2 3 4 5 6 >>> x = 2 >>> y = 2 >>> if x == 2 and y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Notez que le m\u00eame r\u00e9sultat serait obtenu en utilisant deux instructions if imbriqu\u00e9es : 1 2 3 4 5 6 7 >>> x = 2 >>> y = 2 >>> if x == 2 : ... if y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Vous pouvez aussi tester directement l'effet de ces op\u00e9rateurs \u00e0 l'aide de True et False (attention \u00e0 respecter la casse). 1 2 >>> True or False True Enfin, on peut utiliser l'op\u00e9rateur logique de n\u00e9gation not qui inverse le r\u00e9sultat d'une condition : 1 2 3 4 5 6 >>> not True False >>> not False True >>> not ( True and True ) False Instructions break et continue Ces deux instructions permettent de modifier le comportement d'une boucle ( for ou while ) avec un test. L'instruction break stoppe la boucle. 1 2 3 4 5 6 7 8 >>> for i in range ( 5 ): ... if i > 2 : ... break ... print ( i ) ... 0 1 2 L'instruction continue saute \u00e0 l'it\u00e9ration suivante, sans ex\u00e9cuter la suite du bloc d'instructions de la boucle. 1 2 3 4 5 6 7 8 9 >>> for i in range ( 5 ): ... if i == 2 : ... continue ... print ( i ) ... 0 1 3 4 Tests de valeur sur des floats Lorsque l'on souhaite tester la valeur d'une variable de type float , le premier r\u00e9flexe serait d'utiliser l'op\u00e9rateur d'\u00e9galit\u00e9 comme : 1 2 >>> 1 / 10 == 0.1 True Toutefois, nous vous le d\u00e9conseillons formellement. Pourquoi ? Python stocke les valeurs num\u00e9riques des floats sous forme de nombres flottants (d'o\u00f9 leur nom !), et cela m\u00e8ne \u00e0 certaines limitations. Observez l'exemple suivant : 1 2 3 4 >>> ( 3 - 2.7 ) == 0.3 False >>> 3 - 2.7 0.2999999999999998 Nous voyons que le r\u00e9sultat de l'op\u00e9ration 3 - 2.7 n'est pas exactement 0.3 d'o\u00f9 le False en ligne 2. En fait, ce probl\u00e8me ne vient pas de Python , mais plut\u00f4t de la mani\u00e8re dont un ordinateur traite les nombres flottants (comme un rapport de nombres binaires). Ainsi certaines valeurs de float ne peuvent \u00eatre qu'approch\u00e9es. Une mani\u00e8re de s'en rendre compte est d'utiliser l'\u00e9criture format\u00e9e en demandant l'affichage d'un grand nombre de d\u00e9cimales : 1 2 3 4 5 6 7 8 >>> 0.3 0.3 >>> f \" { 0.3 : .5f } \" '0.30000' >>> f \" { 0.3 : .60f } \" '0.299999999999999988897769753748434595763683319091796875000000' >>> f \" { 3 - 2.7 : .60f } \" '0.299999999999999822364316059974953532218933105468750000000000' On observe que lorsqu'on tape 0.3 , Python affiche une valeur arrondie. En r\u00e9alit\u00e9, le nombre r\u00e9el 0.3 ne peut \u00eatre qu'approch\u00e9 lorsqu'on le code en nombre flottant. Il est donc essentiel d'avoir cela en t\u00eate lorsque l'on effectue un test. Conseils Pour les raisons \u00e9voqu\u00e9es ci-dessus, il ne faut surtout pas tester si un float est \u00e9gal \u00e0 une certaine valeur. La bonne pratique est de v\u00e9rifier si un float est compris dans un intervalle avec une certaine pr\u00e9cision. Si on appelle cette pr\u00e9cision delta , on peut proc\u00e9der ainsi : 1 2 3 4 5 6 >>> delta = 0.0001 >>> var = 3.0 - 2.7 >>> 0.3 - delta < var < 0.3 + delta True >>> abs ( var - 0.3 ) < delta True Ici on teste si var est compris dans l'intervalle \\(0.3\u00b1delta\\) . Les deux m\u00e9thodes m\u00e8nent \u00e0 un r\u00e9sultat strictement \u00e9quivalent : La ligne 3 est intuitive car elle ressemble \u00e0 un encadrement math\u00e9matique. La ligne 5 utilise la fonction valeur absolue abs() et est plus compacte.","title":"Tests"},{"location":"Python/tests/#tests","text":"","title":"Tests"},{"location":"Python/tests/#definition","text":"Les tests sont un \u00e9l\u00e9ment essentiel \u00e0 tout langage informatique si on veut lui donner un peu de complexit\u00e9 car ils permettent \u00e0 l'ordinateur de prendre des d\u00e9cisions. Pour cela, Python utilise l'instruction if ainsi qu'une comparaison que nous avons abord\u00e9e au chapitre pr\u00e9c\u00e9dent. Voici un premier exemple : 1 2 3 4 5 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... Le test est vrai ! et un second : 1 2 3 4 >>> x = \"souris\" >>> if x == \"tigre\" : ... print ( \"Le test est vrai !\" ) ... Il y a plusieurs remarques \u00e0 faire concernant ces deux exemples : Dans le premier exemple, le test \u00e9tant vrai, l'instruction print(\"Le test est vrai !\") est ex\u00e9cut\u00e9e. Dans le second exemple, le test est faux et rien n'est affich\u00e9. Les blocs d'instructions dans les tests doivent forc\u00e9ment \u00eatre indent\u00e9s comme pour les boucles for et while . L'indentation indique la port\u00e9e des instructions \u00e0 ex\u00e9cuter si le test est vrai. Comme avec les boucles for et while , la ligne qui contient l'instruction if se termine par le caract\u00e8re deux-points \u00ab : \u00bb.","title":"D\u00e9finition"},{"location":"Python/tests/#tests-a-plusieurs-cas","text":"Parfois, il est pratique de tester si la condition est vraie ou si elle est fausse dans une m\u00eame instruction if . Plut\u00f4t que d'utiliser deux instructions if , on peut se servir des instructions if et else : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 >>> x = 2 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est vrai ! >>> x = 3 >>> if x == 2 : ... print ( \"Le test est vrai !\" ) ... else : ... print ( \"Le test est faux !\" ) ... Le test est faux ! On peut utiliser une s\u00e9rie de tests dans la m\u00eame instruction if , notamment pour tester plusieurs valeurs d'une m\u00eame variable. Par exemple, on se propose de tirer au sort une base d'ADN puis d'afficher le nom de cette derni\u00e8re. Dans le code suivant, nous utilisons l'instruction random.choice(liste) qui renvoie un \u00e9l\u00e9ment choisi au hasard dans une liste. L'instruction import random sera vue plus tard dans le chapitre 8 Modules , admettez pour le moment qu'elle est n\u00e9cessaire. 1 2 3 4 5 6 7 8 9 10 11 12 >>> import random >>> base = random . choice ([ \"a\" , \"t\" , \"c\" , \"g\" ]) >>> if base == \"a\" : ... print ( \"choix d'une ad\u00e9nine\" ) ... elif base == \"t\" : ... print ( \"choix d'une thymine\" ) ... elif base == \"c\" : ... print ( \"choix d'une cytosine\" ) ... elif base == \"g\" : ... print ( \"choix d'une guanine\" ) ... choix d 'une cytosine Dans cet exemple, Python teste la premi\u00e8re condition, puis, si et seulement si elle est fausse, teste la deuxi\u00e8me et ainsi de suite... Le code correspondant \u00e0 la premi\u00e8re condition v\u00e9rifi\u00e9e est ex\u00e9cut\u00e9 puis Python sort du bloc d'instructions du if .","title":"Tests \u00e0 plusieurs cas"},{"location":"Python/tests/#importance-de-lindentation","text":"De nouveau, faites bien attention \u00e0 l'indentation ! Vous devez \u00eatre tr\u00e8s rigoureux sur ce point. Pour vous en convaincre, ex\u00e9cutez ces deux exemples de code : Code 1 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 Le test est vrai car la variable nb vaut 5 Code 2 1 2 3 4 5 nombres = [ 4 , 5 , 6 ] for nb in nombres : if nb == 5 : print ( \"Le test est vrai\" ) print ( f \"car la variable nb vaut { nb } \" ) R\u00e9sultat : 1 2 3 4 car la variable nb vaut 4 Le test est vrai car la variable nb vaut 5 car la variable nb vaut 6 Les deux codes pourtant tr\u00e8s similaires produisent des r\u00e9sultats tr\u00e8s diff\u00e9rents. Si vous observez avec attention l'indentation des instructions sur la ligne 5, vous remarquerez que dans le code 1, l'instruction est indent\u00e9e deux fois, ce qui signifie qu'elle appartient au bloc d'instructions du test if . Dans le code 2, l'instruction de la ligne 5 n'est indent\u00e9e qu'une seule fois, ce qui fait qu'elle n'appartient plus au bloc d'instructions du test if , d'o\u00f9 l'affichage de car la variable nb vaut xx pour toutes les valeurs de nb .","title":"Importance de l'indentation"},{"location":"Python/tests/#tests-multiples","text":"Les tests multiples permettent de tester plusieurs conditions en m\u00eame temps en utilisant des op\u00e9rateurs bool\u00e9ens. Les deux op\u00e9rateurs les plus couramment utilis\u00e9s sont le OU et le ET . Voici un petit rappel sur le fonctionnement de l'op\u00e9rateur OU : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai OU Vrai Vrai Vrai OU Faux Vrai Faux OU Vrai Vrai Faux OU Faux Faux et de l'op\u00e9rateur ET : Condition 1 Op\u00e9rateur Condition 2 R\u00e9sultat Vrai ET Vrai Vrai Vrai ET Faux Faux Faux ET Vrai Faux Faux ET Faux Faux En Python , on utilise le mot r\u00e9serv\u00e9 and pour l'op\u00e9rateur ET et le mot r\u00e9serv\u00e9 or pour l'op\u00e9rateur OU . Respectez bien la casse des op\u00e9rateurs and et or qui, en Python , s'\u00e9crivent en minuscule. En voici un exemple d'utilisation : 1 2 3 4 5 6 >>> x = 2 >>> y = 2 >>> if x == 2 and y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Notez que le m\u00eame r\u00e9sultat serait obtenu en utilisant deux instructions if imbriqu\u00e9es : 1 2 3 4 5 6 7 >>> x = 2 >>> y = 2 >>> if x == 2 : ... if y == 2 : ... print ( \"le test est vrai\" ) ... le test est vrai Vous pouvez aussi tester directement l'effet de ces op\u00e9rateurs \u00e0 l'aide de True et False (attention \u00e0 respecter la casse). 1 2 >>> True or False True Enfin, on peut utiliser l'op\u00e9rateur logique de n\u00e9gation not qui inverse le r\u00e9sultat d'une condition : 1 2 3 4 5 6 >>> not True False >>> not False True >>> not ( True and True ) False","title":"Tests multiples"},{"location":"Python/tests/#instructions-break-et-continue","text":"Ces deux instructions permettent de modifier le comportement d'une boucle ( for ou while ) avec un test. L'instruction break stoppe la boucle. 1 2 3 4 5 6 7 8 >>> for i in range ( 5 ): ... if i > 2 : ... break ... print ( i ) ... 0 1 2 L'instruction continue saute \u00e0 l'it\u00e9ration suivante, sans ex\u00e9cuter la suite du bloc d'instructions de la boucle. 1 2 3 4 5 6 7 8 9 >>> for i in range ( 5 ): ... if i == 2 : ... continue ... print ( i ) ... 0 1 3 4","title":"Instructions break et continue"},{"location":"Python/tests/#tests-de-valeur-sur-des-floats","text":"Lorsque l'on souhaite tester la valeur d'une variable de type float , le premier r\u00e9flexe serait d'utiliser l'op\u00e9rateur d'\u00e9galit\u00e9 comme : 1 2 >>> 1 / 10 == 0.1 True Toutefois, nous vous le d\u00e9conseillons formellement. Pourquoi ? Python stocke les valeurs num\u00e9riques des floats sous forme de nombres flottants (d'o\u00f9 leur nom !), et cela m\u00e8ne \u00e0 certaines limitations. Observez l'exemple suivant : 1 2 3 4 >>> ( 3 - 2.7 ) == 0.3 False >>> 3 - 2.7 0.2999999999999998 Nous voyons que le r\u00e9sultat de l'op\u00e9ration 3 - 2.7 n'est pas exactement 0.3 d'o\u00f9 le False en ligne 2. En fait, ce probl\u00e8me ne vient pas de Python , mais plut\u00f4t de la mani\u00e8re dont un ordinateur traite les nombres flottants (comme un rapport de nombres binaires). Ainsi certaines valeurs de float ne peuvent \u00eatre qu'approch\u00e9es. Une mani\u00e8re de s'en rendre compte est d'utiliser l'\u00e9criture format\u00e9e en demandant l'affichage d'un grand nombre de d\u00e9cimales : 1 2 3 4 5 6 7 8 >>> 0.3 0.3 >>> f \" { 0.3 : .5f } \" '0.30000' >>> f \" { 0.3 : .60f } \" '0.299999999999999988897769753748434595763683319091796875000000' >>> f \" { 3 - 2.7 : .60f } \" '0.299999999999999822364316059974953532218933105468750000000000' On observe que lorsqu'on tape 0.3 , Python affiche une valeur arrondie. En r\u00e9alit\u00e9, le nombre r\u00e9el 0.3 ne peut \u00eatre qu'approch\u00e9 lorsqu'on le code en nombre flottant. Il est donc essentiel d'avoir cela en t\u00eate lorsque l'on effectue un test. Conseils Pour les raisons \u00e9voqu\u00e9es ci-dessus, il ne faut surtout pas tester si un float est \u00e9gal \u00e0 une certaine valeur. La bonne pratique est de v\u00e9rifier si un float est compris dans un intervalle avec une certaine pr\u00e9cision. Si on appelle cette pr\u00e9cision delta , on peut proc\u00e9der ainsi : 1 2 3 4 5 6 >>> delta = 0.0001 >>> var = 3.0 - 2.7 >>> 0.3 - delta < var < 0.3 + delta True >>> abs ( var - 0.3 ) < delta True Ici on teste si var est compris dans l'intervalle \\(0.3\u00b1delta\\) . Les deux m\u00e9thodes m\u00e8nent \u00e0 un r\u00e9sultat strictement \u00e9quivalent : La ligne 3 est intuitive car elle ressemble \u00e0 un encadrement math\u00e9matique. La ligne 5 utilise la fonction valeur absolue abs() et est plus compacte.","title":"Tests de valeur sur des floats"}]}